Punteros
Los punteros tienen como propósito el compartir valores entre los límites del programa.

* Punteros

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Ver el video]]
- Si necesita asistencia financiera, utilice nuestro [[https://www.ardanlabs.com/scholarship/][Formulario de becas]]

Los punteros tienen como propósito el compartir valores entre los límites del programa.
Existen varios tipos de límites en un programa. El más común es entre llamadas a funciones.
Existe otro límite entre Goroutines, como veremos más adelante.

** Revisión de código

- *Ejemplo* *1:* Paso por Valor
- *Ejemplo* *2:* Compartiendo Datos I
- *Ejemplo* *3:* Compartiendo Datos II
- *Ejemplo* *4:* Análisis de Escape
- *Ejemplo* *5:* Crecimiento de la Pila

.play pointers/example1.go
.play pointers/example2.go
.play pointers/example3.go
.play pointers/example4.go
.play pointers/example5.go

Cuando un programa Go empieza, el runtime de Go crea una Goroutine. Las Goroutines son
hilos ligeros en el nivel de aplicación con muchas de las mismas semánticas que los hilos
del sistema operativo. Su trabajo es manejar la ejecución física de un conjunto distinto
de instrucciones. Cada programa Go tiene al menos 1 Goroutine, llamada Goroutine principal.

Cada Goroutine recibe su propio bloque de memoria, llamado pila o stack. Cada pila comienza
como una asignación de 2048 bytes (2k). Es muy pequeña, pero las pilas pueden crecer en tamaño
a lo largo del tiempo.

.image /tour/eng/static/img/p1.png

Cada vez que una función es llamada, un bloque del espacio de la pila es tomado para ayudar
a que la Goroutine ejecute las instrucciones asociadas con esa función. Cada bloque de memoria
individual es llamado marco, o frame.

El tamaño de un frame para una función dada es calculada en tiempo de compilación. Ningún valor
puede ser construido en la pila a menos que el compilador sepa el tamaño de ese valor en
tiempo de compilación. Si el compilador no sabe el tamaño en tiempo de compilación, el valor
tiene que ser construido en el montón, o heap.
 
Las pilas se limpian ellas mismas, y el valor cero ayuda con la inicialización de la pila.
Cada vez que haces una llamada a una función, y el frame de memoria está bloqueado, la memoria
para ese frame queda inicializada, que es lo que hace a la pila auto-limpiante.
Cuando la función retorna, la memoria para el frame se queda ahí pues no se sabe si esa
memoria va a ser necesitada de nuevo. No sería eficiente inicializar la memoria en los retornos.

*Paso* *Por* *Valor*

Todos los datos se mueven por el programa por valor. Ésto significa que, mientras los datos
se pasan entre los límites del programa, cada función o Goroutine recibe su propia copia
de los datos. Existen dos tipos de datos con los que trabajar: el propio valor (entero,
cadena o definido por el usuario), o la dirección de memoria del valor. Las direcciones son datos
que necesitan ser copiados y almacenados entre los límites del programa.

El siguiente código intenta explicar ésto con mayor extensión:

    func main() {

        // Declaración de variable de tipo int con un valor de 10.
        count := 10

        // Para obtener la dirección del valor, utiliza el operador &.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Pasa una copia del "valor de" count (lo que está en la caja)
        // a la función increment1.
        increment1(count)

        // Imprime el "valor de" y "dirección de" count.
        // El valor de count no cambiará después de la llamada a la función.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Pasa una copia de la "dirección de" count (donde está la caja)
        // a la función increment2. Ésto se considera paso por valor y no
        // por referencia porque las direcciones son valores.
        increment2(&count)

        // Imprime el "valor de" y "dirección de" count.
        // El valor de count ha cambiado tras la llamada a la función.
        println(
            "count:\tValue Of[", 
            count, "]\tAddr Of[", &count, "]")
    }

    // increment1 declara la función que acepta su propia copia
    // de un valor entero.
    func increment1(inc int) {

        // Incrementa el valor de la copia local del código que llama.
        inc++
        println("inc1:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
    }

    // increment2 declara la función que acepta su propia copia de
    // una dirección que apunta a un valor entero.
    // Las variables de tipo puntero son tipos literales y son declarados con *.
    func increment2(inc *int) {

        // Incrementa el valor entero del código llamante a través del puntero.
        *inc++
        println(
            "inc2:\tValue Of[", 
            inc, "]\tAddr Of[", &inc, 
            "]\tPoints To[", *inc, "]")
    }

Output:

    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc1:   Value Of[ 11 ]  Addr Of[ 0xc000050730 ]
    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc2:   Value Of[ 0xc000050738 ] Addr Of[ 0xc000050748 ] Points To[ 11 ]
    count:  Value Of[ 11 ]  Addr Of[ 0xc000050738 ]

** Notas

- Usa punteros para compartir datos.
- Los valores en Go son siempre pasador por valor.
- "Valor de", lo que está en la caja. "Dirección de" ( & ), dónde está la caja.
- El operador ( * ) declara una variable de tipo puntero y el "valor al que apunta el puntero".

** Análisis de Escape

El algoritmo que usa el compilador para determinar si un valor debe ser construido
en la pila o en el heap es llamado "análisis de escape". El nombre del algoritmo parece
indicar que los valores son contruídos primero en la pila y luego escapan (o se mueven)
al heap cuando es necesario. Pero éste NO es el caso. La construcción de un valor ocurre
una única vez, y el algoritmo de análisis de escape decide dónde ocurrirá (en la pila
o en el heap). En Go, únicamente la construcción en el heap es denominada
una asignación (allocation).

Comprender el análisis de escape consiste en entender dónde está la propiedad del valor.
La idea es que, cuando un valor es construido dentro del ámbito de una función, entonces
esa función es dueña del valor. En ese momento haz la siguiente pregunta: ¿el valor que está
siendo construido aún debe existir cuando la función que lo posee retorna? Si la respuesta es
no, el valor puede ser contruido en la pila. Si la respuesta es sí, el valor debe ser
construido en el heap.

Nota: la regla de propiedad es una buena regla base para identificar código que causa
asignaciones. Sin embargo, debes apreciar que el análisis de escape tiene alguna imperfección
que puede resulta en asignaciones que no son obvias. Además, el algoritmo busca
oportunidades para aprovechar optimizaciones del compilador y ahorrar asignaciones.

    // user represents a user in the system.
    type user struct {
        name  string
        email string
    }

    func stayOnStack() user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return u
    }

La función stayOnStack utiliza semánticas de valor para retornar un valor de user al
código llamante. En otras palabras, el llamante tiene su propia copia del valor de user
que se está contruyendo.

Cuando la función stayOnStack es llamada y retorna, el valor de user que construye
ya no necesita existir, puesto que el llamante está obteniendo su propia copia. Por tanto,
la construcción del valor de user dentro de stayOnStack puede ocurrir en la pila.
No hay asignación.

    type user struct {
        name  string
        email string
    }

    func escapeToHeap() *user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return &u
    }

La función escapeToHeap utiliza semánticas de puntero para retornar un valor de user
al llamante. En otras palabras, el llamante obtiene acceso compartido (una dirección)
al valor de user en construcción.

Cuando la función escapeToHeap es llamada y retorna, el valor de user que construye
aún necesita existir, puesto que el llamante está obteniendo un acceso compartido al valor.
Por tanto, la construcción del valor de user dentro de escapeToHeap no puede ocurrir
en la pila, debe ocurrir en el heap. Sí hay asignación.

Piensa sobre lo que ocurriría si el valor de user en el último ejemplo fuese contruido
en la pila si utilizásemos semánticas de puntero en el retorno.

.image /tour/eng/static/img/p2.png

El llamante obtendría una copia de la dirección en la pila desde el marco o frame inferior,
y la integridad se perdería. Una vez el control vuelve a la función llamante, la memoria en
la pila donde el valor de usuario existe es reutilizada de nuevo. En el momento que la
función llamante hace una nueva llamada a función, el nuevo marco es movido y la memoria será
sobrescrita, destruyendo el valor compartido.

Por esta razón debes pensar sobre que la pila es auto-limpiante. La inicialización del
valor cero ayuda a que cada marco de pila que necesites a ser limpiado sin el uso del GC.
La pila es auto-limpiando desde que un marco es tomado e inicializado para cada ejecución
de cada llamada a función. La pila es limpiada durante las llamadas a función y no en
los retornos porque el compilador no sabe si la memoria en la pila será necesitada de nuevo.

El análisis de escape decide si el valor es construido en la pila (por defecto) o en el
heap (el escape). Con la función stayOnStack, estamos pasando una copia del valor al llamante,
por lo que es seguro mantener el valor en la pila. Con la función escapeToHeap, estamos
pasando una copia del valor de la dirección de vuelta al llamante (compartiendo la pila)
por lo que no es seguro mantener el valor en la pila.

Existen muchos pequeños detalles relacionados con el análisis de escape, por lo que para
aprender más por favor lee el post en el capítulo 14, titulado Escape Analysis Mechanics.

Nota: Desde la versión 1.17, Go ha cambiado el ABI (application binary interface) para
implementar una nueva manera de pasar argumentos de entrada y salida a funciones, utilizando
registros en lugar de memoria en la pila. Ésto significa que algunos argumentos de función
no serán copiados a la pila, pero algunos podrán serlo dependiendo de la viabilidad del uso
de registros. Ésto no cambia ninguna de las semánticas descritas en el capítulo.

** Notas

- Cuando se puede hacer referencia a un valor después de que regresa la función que construye el valor.
- Cuando el compilador determina que un valor es demasiado grande para se ajuste al tamaño del stack.
- Cuando el compilador no conoce el tamaño del valor en tiempo de compilación.
- Cuando el valor se desacopla mediante del uso de valores de función o interfaz.

** Semánticas de Recolección de Basura (Garbage Collection)

Una vez un valor es contruido en el heap, el Recolector de Basura (GC) tiene que ser
involucrado. La parte más importante del GC es el algoritmo de ritmo, que determina
la frecuencia o ritmo con el que el GC tiene que ejecutarse para mantener el mínimo
heap posible en conjunción con el mejor rendimiento de aplicación.

- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection Semantics Part I]] - William Kennedy

** Pila vs Heap

"La pila es para datos que necesitan persistir sólo por el tiempo de vida de la función
que los construye, y es reclamada sin ningún coste cuando la función termina. El heap
es para los datos que necesitan persistir después de que la función que los construye termina,
y es reclamado por una, algunas veces costosa, recolección de basura." - Ayan George

** Crecimiento de Pila

El tamaño de cada marco para cada función es calculado en tiempo de compilación.
Ésto significa que, si el compilador no sabe el tamaño de un valor en tiempo de compilación,
el valor debe ser construido en el heap. Un ejemplo de esto es el uso de la función
incorporada en el lenguaje make, para construir un slice cuyo tamaño está basado en una variable.

    b := make([]byte, size) // El array de soporte se asigna en el heap.

Go utiliza una implementación de pila contigua para determinar cómo crecen y decrecen las pilas.
Una alternativa que Go podría haber utilizado es una implementación de pila segmentada, que es
usada por algunos sistemas operativos.

Cada llamada a función viene con un pequeño preámbulo que pregunta, "¿Hay suficiente espacio
de pila para este nuevo marco?". Si sí, entonces no hay problema y el marco es obtenido
e inicializado. Si no, entonces una nueva pila más grande debe ser construida y la memoria
de la pila actual debe ser copiada sobre la nueva. Ésto requiere cambios a los punteros que
referencien a la memoria en la pila. Los beneficios de memoria contigua y recorridos lineales
con hardware moderno suponen la compensación por el coste de la copia.

Debido al uso de pilas contiguas, ninguna Goroutine puede tener un puntero a alguna otra
pila de la Goroutine. Habría demasiado overhead para el runtime para mantener el rastro
de cada puntero a cada pila y reajustar esos punteros a la nueva ubicación.

** Lecturas Extra

**Mecánicas* *de* *Punteros*

- [[https://golang.org/doc/effective_go.html#pointers_vs_values][Pointers vs. Values]]    
- [[https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html][Language Mechanics On Stacks And Pointers]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2014/12/using-pointers-in-go.html][Using Pointers In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/understanding-pointers-and-memory.html][Understanding Pointers and Memory Allocation]] - William Kennedy    

*Pilas*

- [[https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub][Contiguous Stack Proposal]]  

*Análisis* *de* *Escape* *e* *Inlining*

- [[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw][Go Escape Analysis Flaws]]  
- [[https://github.com/golang/go/wiki/CompilerOptimizations][Compiler Optimizations]]

*Recolección* *de* *Basura*

- [[http://gchandbook.org/][The Garbage Collection Handbook]]  
- [[https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md][GC Pacer Redesign - 2021]] - Michael Knyszek  
- [[https://en.wikipedia.org/wiki/Tracing_garbage_collection][Tracing Garbage Collection]]  
- [[https://blog.golang.org/go15gc][Go Blog - 1.5 GC]] 
- [[https://www.youtube.com/watch?v=aiv1JOfMjm0&index=16&list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm][Go GC: Solving the Latency Problem]]  
- [[http://rubinius.com/2013/06/22/concurrent-garbage-collection][Concurrent garbage collection]]  
- [[https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit][Go 1.5 concurrent garbage collector pacing]]  
- [[https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md][Eliminating Stack Re-Scanning]]  
- [[https://groups.google.com/forum/m/#!topic/golang-nuts/KJiyv2mV2pU][Why golang garbage-collector not implement Generational and Compact gc?]] - Ian Lance Taylor  
- [[https://blog.golang.org/ismmkeynote][Getting to Go: The Journey of Go's Garbage Collector]] - Rick Hudson  
- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection In Go : Part I - Semantics]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html][Garbage Collection In Go : Part II - GC Traces]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html][Garbage Collection In Go : Part III - GC Pacing]] - William Kennedy  
- [[https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/][Go memory ballast: How I learnt to stop worrying and love the heap]] - Ross Engers  

*Optimizaciones* *Estáticas* *de* *Asignaciones* *Únicas*

- [[https://www.youtube.com/watch?v=D2-gaMvWfQY][GopherCon 2015: Ben Johnson - Static Code Analysis Using SSA]]  
- [[https://godoc.org/golang.org/x/tools/go/ssa][Package SSA]]    
- [[https://www.youtube.com/watch?v=FnGCDLhaxKU][Understanding Compiler Optimization]]

* Ejercicios

Utiliza la plantilla como un punto de partida para completar los ejercicios. Una posible solución es propocionada.

** Ejercicio 1

*Parte* *A*: Declara e inicializa una variable de tipo int con un valor de 20.
Muestra la "dirección de" y el "valor de" la variable.

*Parte* *B:* Declara e inicializa una variable de tipo puntero a int que apunte a
la última variable que creaste. Muestra la "dirección de", "valor de" y el
"valor al que apunta el puntero".

** Ejercicio 2

Declara un tipo struct y crea un valor de este tipo. Declara una función que puede
cambiar el valor de algún campo en este tipo struct. Muestra el valor antes y después
de la llamada a la función.

.play pointers/exercise1.go
.play pointers/answer1.go
.play pointers/exercise2.go
.play pointers/answer2.go
