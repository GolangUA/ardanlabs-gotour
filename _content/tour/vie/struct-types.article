Kiểu Cấu trúc (Struct Types)
Struct types là một cách tạo ra những kiểu phức tạp để nhóm các trường dữ liệu lại với nhau.

* Struct Types

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Xem Video]]
- Cần hỗ trợ Học phí, hãy sử dụng [[https://www.ardanlabs.com/scholarship/] [Đơn xin Học bổng]] của chúng tôi

Struct types là một cách tạo ra những kiểu phức tạp để nhóm các trường dữ liệu lại với nhau.
Đó là một cách rất tốt để tổ chức và chia sẻ các khía cạnh khác nhau của dữ liệu mà
chương trình của bạn sử dụng.

Hiệu suất tiềm năng của kiến trúc máy tính được xác định chủ yếu bởi word length
(số bit có thể được xử lý trên mỗi lần truy cập) và quan trọng hơn là kích thước bộ nhớ
hoặc số lượng word mà nó có thể truy cập.

** Code Review

- *Example* *1:* Khai báo và khởi tạo kiểu struct.
- *Example* *2:* Kiểu struct ẩn danh.
- *Example* *3:* Kiểu Named vs Unnamed. 
- *Example* *4:* Điểu chỉnh kiểu struct.

.play struct-types/example1.go
.play struct-types/example2.go
.play struct-types/example3.go
.play struct-types/example4.go

** Struct và Construction Mechanics

Khai báo này thể hiện một kiểu cụ thể do người dùng định nghĩa dưới dạng tổng hợp của
các trường và loại dữ liệu khác nhau.

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Khai báo một biến kiểu example và khởi tạo nó về trạng thái zero value.

    var e1 example

    fmt.Printf("%+v\n", e1)

Đầu ra:
    
    {flag:false counter:0 pi:0}

Khai báo một biến kiểu example và set giá trị tường minh.

    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e2.flag)
    fmt.Println("Counter", e2.counter)
    fmt.Println("Pi", e2.pi)

Đầu ra:

    Flag true
    Counter 10
    Pi 3.141592

Khai báo một biến kiểu tường minh unnamed và set giá trị khác zero value cho nó bằng
cú pháp xây dựng tường minh.

    e3 := struct {
        flag    bool
        counter int16
        pi      float32
    }{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e3.flag)
    fmt.Println("Counter", e3.counter)
    fmt.Println("Pi", e3.pi)

Đầu ra:

    Flag true
    Counter 10
    Pi 3.141592

Ý tưởng xây dựng tường minh chỉ là xây dựng một cái gì đó unnamed theo nghĩa đen.

Bạn nên sử dụng var cho zero value và toán tử khai báo biến ngắn với
cú pháp { } để xây dựng non-zero value.

** Padding và Alignment

Bao nhiêu bộ nhớ được phân bổ cho một giá trị kiểu example?

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Kiểu bool là 1 byte, int16 là 2 bytes, và float32 là 4 bytes. Cộng tất cả với nhau
và bạn nhận 7 bytes. Tuy nhiên, câu trả lời thực tế là 8 byte. Tại sao, bởi vì có
một byte đệm nằm giữa trường flag và bộ đếm vì lý do căn chỉnh (alignment).

.image /tour/eng/static/img/f1.png

Ý tưởng của alignment là cho phép phần cứng đọc bộ nhớ hiệu quả hơn
bằng cách đặt bộ nhớ trên các ranh giới alignment cụ thể. Trình biên dịch sẽ xử lý
cơ chế ranh giới alignment nên bạn không cần phải làm nữa.

Tùy thuộc vào kích thước của một trường cụ thể và vị trí của nó trong struct, Go
xác định phần đệm (padding) mà bạn cần.

    type example2 struct {
        flag    bool
        counter int16
        flag2   bool
        pi      float32
    }

Trong ví dụ này, tôi đã thêm một trường mới gọi là `flag2` nằm giữa trường counter và pi.
Điều này tạo ra nhiều padding hơn bên trong struct.

    type example2 struct {
        flag    bool     // 0xc000100020 <- Starting Address
                byte     // 0xc000100021 <- 1 byte padding
        counter int16    // 0xc000100022 <- 2 byte alignment
        flag2   bool     // 0xc000100024 <- 1 byte alignment
                byte     // 0xc000100025 <- 1 byte padding
                byte     // 0xc000100026 <- 1 byte padding
                byte     // 0xc000100027 <- 1 byte padding
        pi      float32  // 0xc000100028 <- 4 byte alignment
    }

Đây là cách mà alignment và padding diễn ra nếu giá trị kiểu example2 bắt đầu
tại địa chỉ 0xc000100020. Trường flag đại diện cho địa chỉ bắt đầu và chỉ được
có kích thước 1 byte. Vì trường counter yêu cầu phân bổ 2 byte nên nó
phải được đặt trong bộ nhớ theo alignment 2 byte, nghĩa là nó cần nằm trên một
địa chỉ là bội số của 2. Điều này yêu cầu trường counter bắt đầu tại địa chỉ
0xc000100022 và tạo ra khoảng cách 1 byte giữa trường flag và trường counter.

.image /tour/eng/static/img/f2.png

Trường `flag2` là kiểu bool và có thể rơi vào địa chỉ tiếp theo 0xc000100024.
Trường cuối cùng là pi và cần phân bổ 4 byte nên nó cần một alignment 4 byte.
Địa chỉ tiếp theo cho một giá trị 4 byte là 0xc000100028. Điều đó có nghĩa là
cần thêm 3 byte padding để duy trì sự liên kết phù hợp. Kết quả này trong
giá trị kiểu example2 yêu cầu tổng phân bổ bộ nhớ là 12 byte.

Trường lớn nhất trong struct biểu diễn ranh giới alignment cho toàn bộ struct.
Trong trường hợp này, trường lớn nhất là 4 byte nên địa chỉ bắt đầu cho giá trị
struct này phải là bội số của 4. Bạn có thể thấy địa chỉ 0xc000100020 là một
bội số của 4.

Nếu bạn cần giảm thiểu số lượng byte padding, bạn phải bố trí các trường từ
phân bổ cao nhất đến thấp nhất. Điều này sẽ đẩy byte padding cần thiết bất kỳ
xuống cuối struct và giảm tổng số byte padding cần thiết xuống.

    type example struct {
        pi      float32  // 0xc000100020 <- Starting Address
        counter int16    // 0xc000100024 <- 2 byte alignment
        flag    bool     // 0xc000100026 <- 1 byte alignment
        flag2   bool     // 0xc000100027 <- 1 byte alignment
    }

Sau khi sắp xếp lại các trường, giá trị struct chỉ yêu cầu phân bổ 8 byte
chứ không phải 12 byte. Vì tất cả các trường đều cho phép giá trị struct giảm
trên alignment 4 byte, không cần thêm byte padding.

.image /tour/eng/static/img/f3.png

** Gán giá trị

Nếu bạn có hai kiểu được đặt tên khác nhau nhưng có struct giống hệt nhau, bạn không thể gán
giá trị của cái này với cái kia.

Ví dụ: nếu example1 và example2 được khai báo bằng cách sử dụng cùng một kiểu
và chúng ta khởi tạo hai biến.

    var ex1 example1
    var ex2 example2

Bạn không thể gán hai biến này cho nhau vì chúng có kiểu khác nhau.
Việc chúng giống hệt nhau về cấu trúc là không liên quan.

    ex1 = ex2  // Không được phép, lỗi trình biên dịch

Để thực hiện việc gán này, bạn sẽ phải sử dụng cú pháp chuyển đổi và vì chúng
có cấu trúc giống hệt nhau, trình biên dịch sẽ cho phép điều này.

    ex1 = example1(ex2)  // Được phép, không có lỗi trình biên dịch

Tuy nhiên, nếu ex2 được thay đổi thành khai báo dưới dạng unnamed bằng cách
sử dụng cùng một kiểu khai báo là ex1, thì không cần cú pháp chuyển đổi.

    var ex2 struct {
        flag    bool
        counter int16
        pi      float32
    }

    ex1 = ex2  // Được phép, không cần cú pháp chuyển đổi

Trình biên dịch sẽ cho phép việc gán này mà không cần chuyển đổi.

** Chú ý

- Chúng ta có thể sử dụng mẫu struct tường minh để khởi tạo một giá trị từ kiểu struct.
- Toán tử dấu chấm (.) cho phép chúng ta truy cập vào từng trường giá trị riêng lẻ.
- Chúng ta có thể tạo ra những struct ẩn danh.

** Trích dẫn

"Implicit conversion of types is the Halloween special of coding. Whoever thought
of them deserves their own special hell." - Martin Thompson

** Đọc thêm

- [[https://www.ardanlabs.com/blog/2013/07/understanding-type-in-go.html][Understanding Type in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/object-oriented-programming-in-go.html][Object Oriented Programming in Go]] - William Kennedy    
- [[https://dave.cheney.net/2015/10/09/padding-is-hard][Padding is hard]] - Dave Cheney    
- [[https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/][Structure Member Alignment, Padding and Data Packing]]    
- [[http://www.catb.org/esr/structure-packing][The Lost Art of Structure Packing]] - Eric S. Raymond    

* Bài tập

Sử dụng bài mẫu làm điểm khởi đầu để hoàn thành các bài tập. Một câu trả lời khả thi đã được cung cấp.

** Bài tập 1

*Phần* *A:* Khai báo một kiểu struct để duy trì thông tin về người dùng (tên,
email và tuổi). Tạo một giá trị thuộc loại này, khởi tạo bằng các giá trị và
hiển thị từng trường.

*Phần* *B:* Khai báo và khởi tạo một kiểu struct ẩn danh với ba trường giống nhau.
Hiển thị giá trị.

.chạy struct-types/exercise1.go
.chạy struct-types/answer1.go
