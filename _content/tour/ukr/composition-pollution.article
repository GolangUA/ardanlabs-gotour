Забруднення Інтерфейсами (Interface Pollution)
Забруднення Інтерфейсами випливає з факту того, що люди створюють дизайн додатків за допомогою інтерфейсів замість того щоб відкривати його природно.

* Забруднення Інтерфейсами

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][форму для отримання стипендії]]

Забруднення інтерфейсами випливає з факту того, що люди створюють дизайн програмного забезпечення за допомогою інтерфейсів
замість того, щоб відкривати його природно.

** Перегляд коду

- *Example* *1:* Створіть Забруднення Інтерфейсів
- *Example* *2:* Приберіть Забруднення Інтерфейсів

.play composition/pollution/example1.go
.play composition/pollution/example2.go

** Забруднення Інтерфейсами

Забруднення Інтерфейсами випливає з факту того, що люди проектують програмне забезпечення за допомогою інтерфейсів
замість того, щоб відкривати його природно. Спочатку ви повинні створити
конкретне рішення для проблеми. Потім ви можете зрозуміти де саме програма має бути поліморфною,
або чи має вона такою бути взагалі.

Ось які речі я чув від інших розробників.

"Я використовую інтерфейси тому що ми маємо використовувати інтерфейси".

Ні. Ми не маємо використовувати інтерфейси. Ми використовуємо інтерфейси тоді, коли в цьому є практичний зміст,
або коли це доцільно. У використанні інтерфейсів є своя ціна: певний рівень опосередкованості
та додаткове виділення памʼяті, коли ми зберігаємо значення всередині. Якщо ціна додаткового виділення памʼяті
не переважає того, що ми отримуємо цим опосередкуванням, то використання інтерфейсів треба уникати.

"Я маю тестувати свій код, тому мені треба використовувати інтерфейси".

Ні. Ви маєте створювати свій API в першу чергу для користувача, а не для тестів. Якщо API неможливо відтестувати,
вам треба задатися питанням, чи їм можна користуватися. Також є різні рівні API.
Низькорівневі, не експортовані назовні API, можуть і мають фокусуватися на зручності тестування.
Високорівневі, експортовані назовні API, мають фокусуватися на зручності використання.

Функції, які приймають сирі дані всередину і повертають сирі дані назовні легше за все тестувати.
Відокремлюйте процес трансформації даних від того звідки дані приходять і куди
відправляються. Це та вправа з рефакторингу, яку вам треба робити під час інженерного
циклу розробки.

Нижче можна побачити приклад, який створює забруднення інтерфейсами, використовуючи неналежним чином інтерфейс,
коли він не потрібен.

    type Server interface {
        Start() error
        Stop() error
        Wait() error
    }

Інтерфейс Server визначає контракт для TCP серверу. Проблема тут полягає у тому, що
вам не потрібен контракт, вам потрібна імплементація. Буде існувати лише одна імплементація,
особливо якщо ви саме той/та хто буде її імплементувати. Вам не потрібно, щоб хтось інший
створював вам цю імплементацію.

До того ж, цей інтерфейс заснований на іменнику а не на дієслові. Конкретні типи це іменники,
оскільки вони відображають конкретну проблему. Інтерфейси відображають поведінку,
а Server це не поведінка.

Ось кілька способів, щоб ідентифікувати забруднення інтерфейсами:

- Пакет оголошує інтерфейс, який співпадає із суцільним API свого конкретного типу.
- Інтерфейси експортовані, але конкретні типи, що імплементують їх не експортовані.
- Фабрична функція для конкретного типу повертає значення інтерфейсу з конкретним значенням всередині, яке не експортоване.
- Інтерфейс можна видалити і нічого не зміниться для користувача API.
- Інтерфейс не відокремлює API від змін.

Настанови стосовно забруднення інтерфейсами:

Використовуйте інтерфейси:

- Коли користувачі API мають створювати деталі імплементації.
- Коли API мають декілька імплементацій, які потрібно підтримувати.
- Коли частини API які можуть змінюватися були встановлені і вимагають відокремлення.

Ставте під сумнів необхідність інтерфейсу:

- Якщо його єдина мета це написання зручного для тестування API (напишіть спочатку зручне для використання API)
- Якщо він не надає підтримку відокремлення API від змін.
- Якщо не зрозуміло як інтерфейс робить код кращим.
