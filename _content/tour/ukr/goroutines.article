Горутини (Goroutines)
Горутини це функції, які створюються та управляються планувальником Go (Go scheduler), щоб виконуватися незалежно.

* Горутини

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][формy для отримання стипендії]]

Горутини це функції, які створюються та управляються планувальником Go,
щоб виконуватися незалежно. Планувальник Go відповідальний за управління
та виконання горутин.

** Перегляд коду

- *Приклад* *1:* Горутини та конкурентність
- *Приклад* *2:* Горутини та перемикання контексту
- *Приклад* *3:* Горутини та паралелізм

.play goroutines/example1.go
.play goroutines/example2.go
.play goroutines/example3.go

** Семантика планувальника

Коли Go програма починає виконання, планувальник Go питає у машини (віртуальної або фізичної)
скільки потоків операційної системи може бути виконано паралельно. Це рішення базується на кількості
ядер, які доступні програмі. Для кожного потоку, який може бути виконаний у паралелі, середа
виконання створює потік операційної системи (М) і прикріплює його до структури даних, яка
представляє логічний процесор (Р) усередині програми. Ці М та P представляють обчислювальну
здатність або контекст виконання для середи виконання програми Go.

Також, головна горутина (G) створюється, щоб управляти виконанням інструкцій
на обраних M/P. Так само, як M управляє виконанням інструкцій заліза, 
G управляє виконанням інструкцій M. Це створює новий шар абстракції над операційною
системою, проте передає контроль виконання на рівень застосунку.

.image /tour/eng/static/img/gor1.png

Враховуючи, що планувальник Go знаходиться вище за планувальник операційної системи,
важливо мати деяке розуміння того, як працює планувальник операційної системи і обмеження,
які він накладає на планувальник Go і застосунки.

Планувальник операційної системи має задачу створити ілюзію, що декілька
частин роботи можуть бути виконані одночасно. Навіть якщо це фізично неможливо.
Це вимагає деяких компромісів у дизайні планувальника. Перед тим, як заглиблюватися
далі, важливо визначити значення деяких слів.

*Робота:* Набір інструкцій, які необхідно виконати для роботи застосунку. Ці
інструкції виконуються потоками, яких додаток може мати від одного і більше.

*Потік:* Шлях виконання, який планується та виконується. Потоки відповідальні за виконання
інструкцій на апаратному рівні.

*Стани* *потоку:* Потік може бути в одному з трьох станів: *Виконується*, *Запущений*
або *Очікує*. *Виконується* - значить, що потік виконує призначені інструкції на
залізі, маючи G розташовану на M. *Запущений* - значить, що потік потребує апаратний час, щоб
виконати призначенні йому інструкції, та сидить в черзі виконання. *Очікує* -
значить, що потік чекає на щось, перед тим як продовжити свою роботу. 
Планувальник не займається потоками в стані *Очікує*.

*Конкурентність:* Це значить невизначеність порядку виконання. Іншими словами,
якщо є набір інструкцій, який може бути виконаний у певному порядку, він буде виконаний
в іншому невизначеному порядку, проте виконаний повністю. Сенс у тому, що результат
виконання повного набору інструкцій у будь-якому невизначеному порядку приводить до того
самого результату. Можна казати, що робота може бути зроблена конкурентно, коли порядок
виконання роботи неважливий, до тих пір, доки вся робота не буде виконана.

*Паралелізм:* Це значить робити багато речей одночасно. Щоб досягти цього, треба
мати можливість виконувати два або більше потоків операційної системи одночасно
на залізі.

*Робота* *процесора:* Це та робота, яка не примушує потік природно переходити
у стан очікування. Наприклад, обчислення числа Фібоначчі можна вважати роботою процесора.

*Робота* *вводу/виводу:* Це та робота, яка примушує потік природно переходити
у стан очікування. Наприклад, отримання даних з різних URL-адрес може
вважатися роботою вводу/виводу.

*Синхронізація:* Коли дві або більше горутини потребують доступ до тієї самої локації
памʼяті в один і той самий час, то їх потрібно синхронізувати та чергувати.
Якщо синхронізація не відбувається і хоча б одна з горутин виконує запис даних,
то це приводить до гонитви даних (data races). Гонитва даних є причиною багатьох багів з пошкодженням даних,
які важко знайти.

*Оркестрування:* Коли двом або більше горутинам потрібно просигналізувати одна одній,
з або без даних, необхідно мати механіку оркестрації. Без оркестрації
будь-які гарантії щодо виконання і завершення конкурентної роботи будуть втрачені.
Це може стати причиною всіляких багів із пошкодженням даних.

Є багато дрібних деталей, повʼязаних із семантикою планувальника, тому, щоб дізнатися
більше, читайте три пости у главі 14, яка зветься Планування у Go.

** Основи конкурентності

Почнемо з простої проблеми конкурентності, яка вимагає оркестрації.

    func init() {
        runtime.GOMAXPROCS(1)
    }

Виклик до GOMAXPROCS робиться, щоб виконати Go програму в одному потоці.
Ця програма буде однопоточна і матиме єдині P/M для виконання всіх горутин.
Назва функції написана великими літерами, тому що це також є змінною оточення.
Однак виклик цієї функції перепише змінну.

    g := runtime.GOMAXPROCS(0)

Ця функція дуже важлива при налаштуванні квот процесора у конфігурації контейнера.
При передачі 0 вертається кількість потоків, які буде використовувати Go програма.
Ви повинні впевнитися в тому, що це число збігається з числом потоків операційної системи, 
які доступні у вашому контейнеризованому середовищі. Якщо числа не зійдуться, то програма Go
не працюватиме так добре, як могла би. Ви можете використовувати як змінну оточення, 
так і виклик функції, щоб усe зіставити.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Ця програма вирішує проблему оркестрації. Головна горутина не може дозволити функції
main завершитися, доки не буде гарантії, що дві створені горутини спочатку завершать своє
виконання. WaitGroup це чудовий інструмент для вирішення проблем оркестрації,
які не потребують передавання даних між горутинами. Сигналізування тут відбувається за 
допомогою АРІ, яке дозволяє горутині почекати, доки інші горутини просигналізують, що
вони закінчили виконання.

У цьому коді, ми створюємо WaitGroup з нульовим значенням, і потім одразу викликаємо
метод Add, щоб встановити значення 2 у WaitGroup, що буде співпадати з числом горутин,
які ми створюємо. Коли ви знаєте, скільки горутин буде створено завчасно, ви повинні
викликати метод Add один раз із цим числом. Коли ви не знаєте (як наприклад у стрімінговому
сервісі), тоді виклик Add(1) допустимий.

У кінці функції main робиться виклик Wait. Wait стримує головну горутину від
повернення. Коли функція main повертається, то програма Go припиняє роботу з 
крайнім упередженням. Саме тому управління оркестрацією з правильними гарантіями
важливе. Виклик Wait блокуватиме, доки WaitGroup не встановить своє значення назад
до 0.

У середині програми створюються дві горутини.

    func main() {
        . . .

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Літеральні функції оголошуються і виконуються з використанням ключового слова go.
У цьому моменті ви кажете планувальнику Go виконати ці функції конкурентно. 
Виконати їх у невизначеному порядку. Усередині реалізації кожної горутини є
виклик функції Done. Цей виклик зменшує значення WaitGroup на 1. Коли обидва
виклики до Done зроблені, значення WaitGroup зміниться з 2 до 0 і потім
головній горутині буде дозволено розблокуватися від виклику Wait,
тим самим програма завершиться.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        . . .
    }

Важливою частиною цього патерну оркестрації є тримання викликів Add і Done
в одному полі зору. Намагайтеся не передавати WaitGroup як параметр у функцію,
де виклик може загубитися. Це допоможе зменшити кількість багів.

    Вивід:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Коли ви скомпілюєте та запустите цю програму, ви побачите, як вона виконується конкурентно.
Друга створена горутина була запланована до виконання першою. Вона завершила
свою роботу, і тільки потім друга горутина почала виконання. Обидві закінчили своє виконання
перед тим як програма завершилася. Наступного разу, коли ви запустите цю програму, не буде
гарантії, що ви отримаєте такий самий результат. Єдина гарантія - це те, що програма не завершить
своє виконання, до того як обидві горутини закінчать роботу.

Навіть якщо ви запустите цю програму 100 разів і побачите один і той самий результат,
немає гарантій що це станеться знову. Це може бути дуже ймовірно, проте не гарантовано.
Особливо не гарантовано у різних версіях, операційних системах та архітектурах.

    func main() {
        . . .

        fmt.Println("Waiting To Finish")
        // wg.Wait()                           <-- ЗМІНЕНО

        fmt.Println("\nTerminating Program")
    }

Якщо ви закоментуєте виклик Wait, то що станеться, коли ви запустите цю програму?
Знову таки, немає гарантії, що станеться, проте є різні 
ймовірності.

Програма може поводитися так само, як раніше, враховуючи, що виклики Println є
системними викликами, які дозволяються планувальнику зробити перемикання контексту.
Програма може виконати лише одну з двох горутин, або взагалі завершити виконання одразу.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            // wg.Done()               <-- ЗМІНЕНО
        }()

        . . .
    }

Що станеться, якщо ви забудете викликати Done в одній з горутин? У такому разі,
програма замкнеться, враховуючи, що значення WaitGroup не може знову стати 0. 
Виклик Wait блокуватиме вічно.

    Вивід:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    fatal error: all goroutines are asleep - deadlock!

    goroutine 1 [semacquire]:
    sync.runtime_Semacquire(0xc00001a0a8)
        /usr/local/go/src/runtime/sema.go:56 +0x45
    sync.(*WaitGroup).Wait(0xc00001a0a0)
        /usr/local/go/src/sync/waitgroup.go:130 +0x65
    main.main()
        concurrency/goroutines/example1/example1.go:42 +0x145
    exit status 2

Ви можете побачити, як середа виконання Go визначає, що програма взаємно блокується на рядку 42,
де виклик Wait відбувається. Вам не варто занадто сильно захоплюватися розпізнаванням 
взаємного блокування, оскільки кожну окрему горутину потрібно заблокувати без виходу.
Це демонструє, чому викликати Add і Done разом так важливо.

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)              <-- ЗМІНЕНО, число занадто мале

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Що станеться, якщо ви не надасте WaitGroup коректну кількість горутин, на які 
треба зачекати? Якщо число занадто велике, ви отримаєте взаємне блокування. Якщо
число занадто мале, то немає гарантій що вся робота закінчиться, до того, як програма
піде далі. Вивід програми невизначений.

** Випереджуваний планувальник

Навіть враховуючи, що планувальник виконується на рівні застосунку, важливо побачити,
як планування випереджає. Це значить, що ви не можете передбачити, коли перемикнеться
контекст і це змінюватиметься кожен раз, коли ви будете запускати програму.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            printHashes("A")
            wg.Done()
        }()

        go func() {
            printHashes("B")
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Ми використовуємо той самий патерн оркестрування як і раніше, проте в цій програмі кожна
горутина робить набагато більше роботи. Роботу, на яку планувальник не виділить горутині 
достатньо часу, щоб закінчити повністю за один проміжок часу.

    func printHashes(prefix string) {
        for i := 1; i <= 50000; i++ {
            num := strconv.Itoa(i)
            sum := sha1.Sum([]byte(num))
            fmt.Printf("%s: %05d: %x\n", prefix, i, sum)
        }
        fmt.Println("Completed", prefix)
    }

Ця функція виконує набагато більше роботи вводу/виводу, яка має потенціал
перемикання контексту.

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A
    B
    A
    B
    A
    B
    A  9 Context Switches

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A  3 Context Switches

Як ви можете побачити, кожен раз коли ви запускаєте програму, стається різна кількість
перемикань контексту. Це чудово, тому що планувальник не повинен бути передбачуваним.
Конкурентність повинна залишатися невизначеною, і ви маєте про це памʼятати, коли
використовуєте її для вирішення проблем продуктивності.

    func init() {
        runtime.GOMAXPROCS(2)
    }

Що станеться, якщо ми повернемось до початкової програми, але змінимо GOMAXPROCS, щоб Go програма виконувалася як двопоточна?

    Вивід:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N a b c d e f g h i j k l m n o O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Тепер можна побачити, що конкурентність програми більш детальна. Вивід літер невизначений
та невпорядкований.

** Примітки

- Горутини - це функції, які плануються виконуватись незалежно.
- Ми повинні завжди мати на увазі кількість активних горутин, та завершувати роботу чисто.
- Конкурентність - це не паралелізм.

- Конкурентність - це мати справу з багатьма речами водночас.
- Паралелізм - це робити багато речей одночасно.

"Паралелізм - це коли дві або більше речі фізично робляться одночасно. Конкурентність це невизначене, невпорядковане виконання." - William Kennedy

"За замовчуванням, горутини не повинні жити довше ніж функція, де вони були створені. Це задає гарний тон проєктування." - Peter Bourgon

** Принципи проєктування

- Дізнайтеся більше про конкурентні [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#concurrent-software-design][патерни проєктування]].

** Додаткові матеріали

- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html][Scheduling In Go - Part I]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html][Scheduling In Go - Part II]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html][Scheduler Tracing In Go]] - William Kennedy   
- [[https://blog.golang.org/advanced-go-concurrency-patterns][Advanced Go Concurrency Patterns]] - Sameer Ajmani    
- [[https://blog.golang.org/context][Go Concurrency Patterns: Context]] - Sameer Ajmani    
- [[https://blog.golang.org/concurrency-is-not-parallelism][Concurrency is not parallelism]] - Rob Pike    
- [[https://talks.golang.org/2013/distsys.slide][Go, for Distributed Systems]] - Russ Cox    
- [[https://docs.google.com/document/d/1At2Ls5_fhJQ59kDK2DFVhFu3g5mATSXqqV5QrxinasI/edit][Go 1.5 GOMAXPROCS Default]]    
- [[https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html][Concurrency, Goroutines and GOMAXPROCS]] - William Kennedy    
- [[http://www.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf][The Linux Scheduler: a Decade of Wasted Cores]]    
- [[https://news.ycombinator.com/item?id=12460807][Explanation of the Scheduler]]    
- [[http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/][15 Years of Concurrency]] - Joe Duffy    
- [[https://www.quora.com/How-does-the-golang-scheduler-work/answer/Ian-Lance-Taylor][How does the golang scheduler work?]] - Ian Lance Taylor    
- [[https://www.youtube.com/watch?v=YHRO5WQGh0k][The Scheduler Saga]] - Kavya Joshi    

* Вправи

Використовуйте шаблон, як стартову точку для виконання вправ. Можливе рішення надано.

** Вправа 1

*Частина* *A* Створіть програму, яка визначає дві анонімних функції. Одну, яка рахуватиме від 100 до 0,
та іншу, яка рахуватиме від 0 до 100. Виведіть на екран кожне число з унікальним ідентифікатором
для кожної горутини. Потім створіть горутини з цих функцій і не дайте функції main завершити виконання,
до того, як горутини закінчать свою роботу.

*Частина* *B* Виконайте програму паралельно.

.play goroutines/exercise1.go
.play goroutines/answer1.go
