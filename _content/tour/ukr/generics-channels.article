Канали
Дізнайтеся як команда Go могла б додати пакет з конкурентними моделями у стандартну бібліотеку завдяки узагальненим типам.

* Узагальнені типи (Generics) - канали (channels)

Дізнайтеся як команда Go могла б додати пакет з конкурентними моделями у стандартну бібліотеку завдяки узагальненим типам.

** Відео

Дивіться мою доповідь про узагальнені типи, в якій ми пройдемось по всім
прикладам, наведеним у цій секції.

.html generics-video.html

** Перегляд коду

- *Приклад* *1*: Функія-робітник (Work function)
- *Приклад* *2*: Обʼєднання (Pooling) 

.play generics/channels/example1.go
.play generics/channels/example2.go

** Пояснення

Потрібно визначити канали і функції використовуючи узагальнені типи.

    type workFn[Result any] func(context.Context) Result

У цьому прикладі оголошений тип представляє функцію, яка приймає контекст 
та повертає узагальнене значення типа Result. Ця декларація описує функцію,
яка робитиме конкурентну роботу і результат цієї роботи.

    func doWork[Result any](ctx context.Context, work workFn[Result]) chan Result {
        ch := make(chan Result, 1)
        
        go func() {
            ch <- work(ctx)
            fmt.Println("doWork : work complete")
        }()
        
        return ch
    }

Тепер напишемо функцію doWork, яка виконуватиме задану функцію-робітника
конкурентно і повертатиме канал, щоб той хто викликав функцію, міг отримати результат роботи
виконаний функцією-робітником. Узагальнений тип Result визначений, щоб представити
тип, який повертається для функції-робітника та типу каналу.

В імплементації функції doWork ми використовуємо буферизований канал з
узагальненим типом Result. Цей канал повертається тому, хто викликав функцію, щоб
отримати результат конкурентної роботи. В середині функції, створюється горутина, щоб
виконати фукнцію-робітник конкуретно. Коли функція-робітник завершує виконання, значення,
що поверається, відправляється назад до того, хто викликав, через канал.

Побудуємо маленьку програму, щоб протестувати функцію doWork.

    func main() {
        duration := 100 * time.Millisecond
        
        ctx, cancel := context.WithTimeout(context.Background(), duration)
        defer cancel()
        
        dwf := func(ctx context.Context) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return "work complete"
        }

        result := doWork(ctx, dwf)
        
        select {
            case v := <-result:
                fmt.Println("main:", v)
            case <-ctx.Done():
                fmt.Println("main: timeout")
        }
    }

Вивід:

    doWork : work complete
    main: work complete

Програма оголошує контекст з тайм-аутом у 100 мілісекунд на старті.
Потім визначається функція-робітник, яка чекатиме 200 мілісекунд перед тим,
як повернути рядок "work complete". З наявним контекстом та функцією-робітником,
викликається функція doWork, яка повертає канал, який присвоюється
у змінну result.

Компілятор спроможний визначити конкретнй тип, який використовується для узагальненого типа
Result, перевіривши тип повернення функції-робітника, яку ми передаємо у функцію
doWork. Це чудово, тому що це означає, що вам не треба кожен раз явно передавати тип,
щоб викликати doWork.

Маючи канал з рядковим типом призначений до змінної result, select case використовується,
щоб почекати на отримання значення з result, або на тайм-аут. Функція doWork може бути
використана, щоб виконати будь яку конкуретну роботу для будь якого конкретнного
типу.

Така сама ідея може бути застосована до обʼєднання горутин, яке зможе виконувати
роботу з узагальненими вхідними параметрами та повертати узагальнений результат.

type workFn[Input any, Result any] func(input Input) Result

У цьому прикладі ми змінили тип функції, щоб приймати узагальнені вхідні параметри
та повертати узагальнений результат.

    func poolWork[Input any, Result any](size int, work workFn[Input, Result]) (chan Input, func()) {
        var wg sync.WaitGroup
        wg.Add(size)
        
        ch := make(chan Input)
        
        for i := 0; i < size; i++ {
            go func() {
                defer wg.Done()
                for input := range ch {
                    result := work(input)
                    fmt.Println("pollWork :", result)
                }
            }()
        }
        
        cancel := func() {
            close(ch)
            wg.Wait()
        }

        return ch, cancel
    }

У функції poolWork оголошені такі самі два узагальнених типа, щоб репрезентувати 
вхідні параметри та тип значення, що повертається із функції-робітника. WaitGroup створюється,
щоб управляти життєвим циклом горутини в обʼєднанні. Потім створюєтья канал з узагальненим
типом Input. Цей канал використовується горутинами в обʼєднанні, щоб отримати вхідні дані
для функції-робітника.

Потім створюється обʼєднання горутин, де кожна горутина чекає на отримання параметрів,
використовуючи for-range цикл для каналу. Під кінець, функція cancel створюється, щоб
дозволити тому, хто зробить її виклик, завершити обʼєднання горутин і дочекатися доки всі горутини
просигналізують, що вони завершили виконання.

Створимо навеличку програму, щоб протестувати функцію poolWork.

    func main() {
        size := runtime.GOMAXPROCS(0)
        
        pwf := func(input int) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return fmt.Sprintf("%d : received", input)
        }

        ch, cancel := poolWork(size, pwf)
        defer cancel()
        
        for i := 0; i < 4; i++ {
            ch <- i
        }
    }

Вивід:

    pollWork : 3 : received
    pollWork : 2 : received
    pollWork : 1 : received
    pollWork : 0 : received

Розмір обʼєднання обчислюється враховуючи кількість горутин, які можуть бути виконані паралельно.
Потім створюється функція-робітник, яка очікує випадкову кількість часу, після чого
повертає рядок, який репрезентує вхідні дані для обʼєднання горутин.


Після цього функція poolWork виконується і канал з функцією cancel повертається.
Функція cancel відтерміновується і далі створюється цикл, який надсилає 4 значення
у обʼєднання горутин. Вивід буде відрізнятися при кожному запуску програми,
тому що вся робота виконується конкурентно.

Ці маленькі приклади надають розуміння, як може бути створений
конкурентний пакет.
