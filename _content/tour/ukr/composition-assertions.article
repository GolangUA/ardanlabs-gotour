Конвертація (Type Conversion) та Твердження (Type Assertion) типів
Навчіться тому як працюють Конвертація та Твердження типів.

* Конвертація та Твердження типів

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][форму для отримання стипендії]]

Конвертація типів дозволяє перетворити дані одного типу в інший.
Твердження типу дозволяє запитати чи зберігається значення певного типу в даному інтерфейсі.

** Перегляд коду

- *Приклад* *1:* Конвертація інтерфейсів
- *Приклад* *2:* Твердження типів в рантаймі
- *Приклад* *3:* Зміна поведінки

.play composition/assertions/example1.go
.play composition/assertions/example2.go
.play composition/assertions/example3.go

** Неявна конвертація інтерфейсів

Як ви могли побачити в попередньому прикладі, значення інтерфейсу одного типу
може бути передано, як значення інтерфейсу іншого типу, якщо конкретне значення,
яке збережене в інтерфейсі, імплементує обидві поведінки.
Це можна вважати неявною конвертацією інтерфейсів, але краще думати про те,
як конкретні дані рухаються крізь інтерфейси у відокремленому стані.

    type Mover interface {
        Move()
    }

    type Locker interface {
        Lock()
        Unlock()
    }

    type MoveLocker interface {
        Mover
        Locker
    }

Маючи ці три інтерфейси, де MoveLocker це композиція Mover та Locker.

    type bike struct{}

    func (bike) Move() {
        fmt.Println("Moving the bike")
    }

    func (bike) Lock() {
        fmt.Println("Locking the bike")
    }

    func (bike) Unlock() {
        fmt.Println("Unlocking the bike")
    }

Та маючи цей конкретний тип bike, що імплементує всі три інтерфейси. Що ви можете зробити?

    var ml MoveLocker
    var m Mover

Ви можете створити значення типу MoveLocker та Mover з нульовим значенням.
Ці значення/змінні(ml і m) інтерфейсів(MoveLocker і Mover) насправді не мають значення.

    ml = bike{}

Потім ви можете створити значення типу bike з нульовим значенням
та призначити копію змінній ml, що має тип MoveLocker. Це можливо завдяки тому,
що bike імплементує всі три поведінки, а компілятор може побачити, що імплементація існує.

    m = ml

Потім ви можете призначити змінну ml із типом MoveLocker змінній m із типом Mover.
Це можливо, тому що ми призначаємо змінній не значення інтерфейсу ml, а конкретне значення,
яке зберігається всередині ml, тобто значення bike. Компілятор знає, що будь яке конкретне значення збережене
всередині ml має також імплементувати інтерфейс Mover.

У той самий час це призначення не валідне.

    ml = m

Вивід:

    неможливо використати m (тип Mover) як тип MoveLocker в призначенні:
        Mover не імплементує MoveLocker (відсутній метод Lock)


Ви не можете призначити змінну m типу Mover назад в змінну ml типу MoveLocker,
оскільки компілятор має можливості гарантувати тільки те, що конкретне значення,
збережене всередині m, знає як виконувати поведінку Move. На етапі компіляції компілятор не знає
чи може конкретне значення виконувати поведінку Lock та Unlock.

** Механіка твердження типів

Твердження типів дозволяє вам в рантаймі поставити запитання, чи присутнє значення
певного типу всередині інтерфейсу. Ви можете подивитися це за допомогою синтаксису m.(bike)

    b := m.(bike)
    ml = b

В цьому випадку ви питаєте, чи збережене значення bike в середині m в момент виконання коду.
Якщо так, то змінній b призначається копія значення, що зберігає bike.
Потім копія може бути скопійована в змінну типу ml.

Якщо значення збережене в інтерфейсі не є значенням bike, то програма панікує.
Це необхідно, щоб забезпечити абсолютну впевненість, що збережене значення має тип bike.
Але що як є шанс, що це не так і це правильна поведінка? В цьому випадку вам потрібна друга форма твердження типів.

    b, ok := m.(bike)

В цій формі, якщо ok має значення true, то в інтерфейсі збережене значення bike,
а якщо false, то ні, і програма не панікує.
Змінна b, в той самий час, все ще має тип bike, але їй призначається нульове значення.

    func main() {
        mvs := []fmt.Stringer{
            Car{},
            Cloud{},
        }

        for i := 0; i < 10; i++ {
            rn := rand.Intn(2)

            if v, is := mvs[rn].(Cloud); is {
                fmt.Println("Got Lucky:", v)
                continue
            }

            fmt.Println("Got Unlucky")
        }
    }

Припустимо, програма оголошує два типи, що звуться Car та Cloud,
кожен з яких імплементує інтерфейс fmt.Stringer, ви можете створити колекцію,
яка дозволяє вам зберігати значення як Car так і Cloud.
Потім ви 10 разів випадковим чином обираєте число від 0 до 1, та виконуєте твердження типу,
щоб подивитися, чи значення за цим випадковим індексом містить значення типу Cloud.
Друга форма твердження типів в даному випадку вирішальна.
