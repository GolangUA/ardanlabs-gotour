Зрізи (Slices)
Зрізи є надзвичайно важливою структурою даних у Go. Вони є основою того, як ми керуємо і маніпулюємо даними у гнучкий, продуктивний і водночас динамічний спосіб. Всім Go розробникам напрочуд важливо знати, як працюють зрізи і як їх використовувати.

* Зрізи

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][формy для отримання стипендії]]

Зрізи є надзвичайно важливою структурою даних у Go. Вони є основою того,
як ми керуємо і маніпулюємо даними у гнучкий, продуктивний і водночас динамічний спосіб. Всім
Go розробникам напрочуд важливо знати, як працюють зрізи і як їх використовувати.

.image /tour/eng/static/img/sl1.png

** Перегляд коду

- *Приклад* *1:* Оголошення і Довжина
- *Приклад* *2:* Типи посилань
- *Приклад* *3:* Доповнення зрізів
- *Приклад* *4:* Зрізаємо зрізи
- *Приклад* *5:* Зрізи і посилання
- *Приклад* *6:* Рядки і зрізи
- *Приклад* *7:* Варіативні функції
- *Приклад* *8:* Механіка меж
- *Приклад* *9:* Ефективні обходи
- *Приклад* *10:* Трьохіндексні зрізи

.play slices/example1.go
.play slices/example2.go
.play slices/example3.go
.play slices/example4.go
.play slices/example5.go
.play slices/example6.go
.play slices/example7.go
.play slices/example8.go
.play slices/example9.go 
.play slices/example10.go

** Створення зрізів

Створювати зрізи можна багатьма способами.

    // Зріз рядків, встановлений у стан нульового значення.
    var slice []string

    // Зріз рядків, встановлений у стан пустого значення.
    slice := []string{}

    // Зріз рядків, встановлений у довжину і ємність 5.
    slice := make([]string, 5)

    // Зріз рядків, встановлений у довжину 5 і ємність 8.
    slice := make([]string, 5, 8)

    // Зріз рядків зі значеннями у довжину 5 і ємність 5.
    slice := []string{"A", "B", "C", "D", "E"}

Ви можете побачити, що вбудована функція make дозволяє попередньо виділити як довжину, так і
ємність для базового масиву. Якщо компілятор знає розмір під час компіляції,
базовий масив може бути побудований на стеку.

** Довжина і ємність зрізів (Length vs Capacity)

Довжина зрізу представляє собою кількість елементів, які можна зчитувати та
записувати. Ємність представляє загальну кількість елементів, що існують
у базовому масиві з позиції покажчика.

Завдяки синтаксичному цукру, зрізи схожі на масиви.

    slice := make([]string, 5)
    slice[0] = "Apple"
    slice[1] = "Orange"
    slice[2] = "Banana"
    slice[3] = "Grape"
    slice[4] = "Plum"

Ви можете помітити різницю між масивами та зрізами у тому, що масиви мають визначений розмір
під час компіляції, на відміну від зрізів, де це не є необхідним.

Якщо ви спробуєте отримати доступ до елемента, що перевищує довжину зрізу, ви отримаєте помилку виконання.

    slice := make([]string, 5)
    slice[5] = "Raspberry"

Помилка компілятора:

    Error: panic: runtime error: index out of range slice[5] = "Runtime error"

У цьому прикладі довжина зрізу дорівнює 5, і я намагаюся отримати доступ до
неіснуючого 6-го елементу.

** Семантичні рекомендації щодо даних для зрізів

Якщо ви працюєте з даними, які є зрізом, тоді використовуйте семантику значення
для переміщення даних по програмі. Це включає оголошення полів у типі.

    func Foo(data []byte) []byte

    type Foo struct {
        X []int
        Y []string
        Z []bool
    }

Це стосується всіх внутрішніх структур даних (мапи, канали, зрізи, інтерфейси та функції).

Одна з причин переходу на семантику вказівника полягає в тому, що вам потрібно надати спільний доступ до зрізу для
декодування або демаршалювання. Використання покажчиків для таких типів операцій
є нормальним, але задокументуйте це, якщо це неочевидно.

** Схема безперервної пам'яті (Contiguous Memory Layout)

Ідея зрізу полягає в тому, щоб мати масив, який є найефективнішою структурою даних
для апаратного забезпечення. Однак вам все одно потрібна здатність
бути динамічними і ефективними із обсягом даних, який потрібен під час виконання та майбутнього зростання.

    func main() {
        slice := make([]string, 5, 8)
        slice[0] = "Apple"
        slice[1] = "Orange"
        slice[2] = "Banana"
        slice[3] = "Grape"
        slice[4] = "Plum"

        inspectSlice(slice)
    }

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i := range slice {
            fmt.Printf("[%d] %p %s\n", i, &slice[i], slice[i])
        }
    }

Вивід:

    Length[5] Capacity[8]
    [0] 0xc00007e000 Apple
    [1] 0xc00007e010 Orange
    [2] 0xc00007e020 Banana
    [3] 0xc00007e030 Grape
    [4] 0xc00007e040 Plum

Функція inspectSlice показує, що зріз має безперервний базовий масив із передбачуваною
відстанню між елементами. Також можна побачити, що зріз має довжину та ємність,
які можуть бути різними. Зверніть увагу, що функція print виконує ітерації лише
по довжині зрізу.

** Доповнення зрізів (Appending With Slices)

Мова програмування надає вбудовану функцію append для додавання значень до
існуючого зрізу.

    var data []string

    for record := 1; record <= 102400; record++ {
        data = append(data, fmt.Sprintf("Rec: %d", record))
    }

Функція append працює зі зрізом, навіть коли зріз ініціалізовано до
стану нульового значення. Дизайн API функції append є цікавим, оскільки він використовує
семантичну мутацію значення. Append отримує власну копію значення зрізу, змінює свою
власну копію, а потім повертає копію користувачеві.

Чому API розроблено саме так? Це тому, що ідіомою є використання семантики значення
для переміщення значення зрізу по програмі. Цього все одно потрібно дотримуватися навіть
під час операції мутації. До того ж, семантична мутація значення є найбезпечнішим способом виконання мутації,
оскільки мутація виконується окремо на власній копії даних функції.

Append завжди підтримує суміжний блок пам’яті для базового масиву зрізу,
навіть після збільшення. Це важливо для заліза.

.image /tour/eng/static/img/sl2.png

Кожного разу, коли викликається функція append, вона перевіряє, чи однакові
довжина та ємність зрізу. Якщо вони однакові, це означає, що більше
немає місця у базовому масиві для нового значення. В такому випадку, append створює
новий базовий масив (подвоюючи або додаючи 25%) і потім копіює значення зі
старого масиву у новий. Тільки після цього можна дописати нове значення.

.image /tour/eng/static/img/sl3.png

Якщо вони не однакові, це означає, що існує додатковий елемент ємності
для додавання. З ємності береться елемент і додається до довжини
зрізу. Це робить операцію додавання дуже ефективною.

Якщо базовий масив ємністю 1024 елементи чи менше, нові базові масиви
створюються шляхом подвоєння розміру існуючого масиву. Як тільки базовий масив
переростає 1024 елементи, збільшення відбувається на 25%.

*Нотатка:* *Як* *функція* *append* *наразі* *нарощує* *ємність*
*базового* *масиву* *з* *версії* *Go* *1.18.*

- [[https://tip.golang.org/doc/go1.18#runtime][https://tip.golang.org/doc/go1.18#runtime]]

** Нарізання зрізів (Slicing Slices)

Зрізи дають можливість уникати додаткових копій та розподілу купи базового
масиву, коли потрібно ізолювати певні елементи базового масиву для різних
операцій.

Синтаксис нарізання представлено у вигляді напіввідкритого інтервалу [a:b) що означає
елементи від індексу a до b, але не включаючи b.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]

Змінна slice2 тепер має значення нового зрізу, що використовує той самий базовий
масив, що й slice1. Проте, slice2 лише дозволяє мати доступ до елементів
за індексом 2 та 3 (C і D) оригінального базового масиву зрізу. Довжина
slice2 тепер 2, а не 5 як у slice1, та ємність 3, оскільки тепер там
3 елементи з тієї позиції покажчика.

.image /tour/eng/static/img/sl4.png

Кращий спосіб думати про нарізання - це зосередитись на довжині, використовуючи нотацію
[a:a+len] індексу від a до a з додаванням довжини. Це зменшить кількість помилок
в обчисленні нових зрізів.

Використаймо цю оглядову функцію.

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i, s := range slice {
            fmt.Printf("[%d] %p %s\n",
                i,
                &slice[i],
                s)
        }
    }

Тепер подивіться на це в дії.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Вивід:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 C     <-- SAME AS INDEX 2 IN SLICE 1
    [1] 0xc00007e030 D     <-- SAME AS INDEX 3 IN SLICE 1

Зверніть увагу, що два різні зрізи використовують один і той самий базовий масив. Це
можна побачити, порівнявши адреси.

Краса в тому, що тут немає виділень пам'яті. Компілятор знає довжину
базового масиву для slice1 під час компілювання. Передаючи копію зрізу
далі до функції inspectSlice, зберігає все в стеку.

** Мутації базового масиву

Якщо використати slice2 для зміни значення рядка з індексом 0, значення будь-якого зрізу,
що використовує той самий базовий масив (де адреса для цього індексу це частина
довжини цього зрізу), також побачить зміну.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2[0] = "CHANGED"
    inspectSlice(slice1)
    inspectSlice(slice2)

Вивід:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 CHANGED
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 CHANGED
    [1] 0xc00007e030 D

Коли змінюєте значення за індексом, завжди беріть до уваги, чи
базовий масив використовується спільно з іншим зрізом.

.image /tour/eng/static/img/sl5.png

А якщо замість цього використати вбудовану функцію append?

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Вивід:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 CHANGED
    Length[3] Capacity[3]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D
    [2] 0xc00007e040 CHANGED

Функція append створює той самий побічний ефект, але він прихований. У цьому випадку
збільшення довжини за рахунок ємності для slice2 спричинило зміну значення за адресою
0xc00007e040. На жаль, slice1 вже мала цю адресу як
частину своєї довжини.

.image /tour/eng/static/img/sl6.png

Один із способів запобігти побічному ефекту — використовувати зріз із трьома індексами під час побудови
slice2, щоб довжина та ємність були однаковими для 2.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Вивід:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[2]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D

Синтаксис для трьохіндексного зрізу виглядає як [a:b:c], коли b та c повинні бути однаковими,
оскільки [a-b] задає довжину, а [a-c] задає ємність. Тепер довжина і
ємність slice2 однакові.

Тепер ви можете використовувати вбудовану функцію append знову, як і раніше.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Вивід:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[3] Capacity[4]
    [0] 0xc000016080 C
    [1] 0xc000016090 D
    [2] 0xc0000160a0 CHANGED

Зауважте, що після виклику append slice2 має новий базовий масив.

.image /tour/eng/static/img/sl7.png

Це можна побачити, порівнявши адреси кожного зрізу. У цьому випадку
мутація slice2 не викликала побічного ефекту для slice1.

** Copying Slices Manually

Існує вбудована функція copy, що дозволяє поверхневе копіювання
зрізів. Оскільки рядок має базовий масив байтів, які є незмінними, його
можна використовувати як джерело, але не як призначення.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice3 := make([]string, len(slice1))
    copy(slice3, slice1)

    inspectSlice(slice1)
    inspectSlice(slice3)

Вивід:

    Length[5] Capacity[5]
    [0] 0xc00005c050 A
    [1] 0xc00005c060 B
    [2] 0xc00005c070 C
    [3] 0xc00005c080 D
    [4] 0xc00005c090 E
    Length[5] Capacity[5]
    [0] 0xc00005c0a0 A
    [1] 0xc00005c0b0 B
    [2] 0xc00005c0c0 C
    [3] 0xc00005c0d0 D
    [4] 0xc00005c0e0 E

Поки цільовий зріз має належний тип і довжину, вбудована
функція copy може виконувати поверхневе копіювання.

** Зрізи використовують семантичну мутацію покажчика

Важливо пам’ятати, що навіть якщо ви використовуєте семантику значення для переміщення зрізу
по програмі, під час читання та запису зрізу ви використовуєте семантику покажчика.
Спільне використання окремих елементів зрізу з різними частинами моєї програми може
спричинити небажані побічні ефекти.

    // Створюємо зріз із 1 користувачем, встановлюємо покажчик на цього користувача,
    // використовуємо цей покажчик для оновлення лайків
    users := make([]user, 1)
    ptrUsr0 := &users[0]
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Вивід:

    User: 0 Likes: 1

Зріз зберігає колекції користувачів. Потім вказівник встановлюється на
першого користувача та використовується для оновлення лайків. Результат показує, що використання покажчика
працює.

.image /tour/eng/static/img/sl8.png

Потім новий користувач додається до колекції, і вказівник знову використовується,
щоб поставити лайк першому користувачеві.

    // Append a new user to the collection. Use the pointer again
    // to update likes.

    users = append(users, user{})
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Вивід:

    User: 0 Likes: 1
    User: 1 Likes: 0

Однак, оскільки функція append замінила базовий масив на новий,
покажчик оновлює старий базовий масив, і лайки втрачаються. Результат
показує, що лайки для першого користувача не зросли.

.image /tour/eng/static/img/sl9.png

Ви повинні бути обережними, знаючи, чи використовуватиметься зріз в операції додавання
під час виконання програми. Необхідно зважити те, як ви використовуєте
зріз. Спільне використання окремих індексів може бути не найкращою ідеєю. Спільне використання
цілого значення зрізу також може не спрацювати, коли виконується додавання. Ймовірно,
використання зрізу як поля в структурі та спільне використання значення структури є
кращим шляхом.

** Ефективність лінійного обходу (Linear Traversal Efficiency)
Краса зрізів полягає в їх здатності виконувати лінійні обходи,
які є механічно симпатичними під час обміну даними з використанням семантики значень для
мінімізації розподілу купи.

    x := []byte{0x0A, 0x15, 0x0e, 0x28, 0x05, 0x96, 0x0b, 0xd0, 0x0}

    a := x[0]
    b := binary.LittleEndian.Uint16(x[1:3])
    c := binary.LittleEndian.Uint16(x[3:5])
    d := binary.LittleEndian.Uint32(x[5:9])

    println(a, b, c, d)

Код виконує лінійний обхід, створюючи значення зрізів, які читають
різні розділи масиву байтів від початку до кінця.

.image /tour/eng/static/img/sl10.png

Усі дані в цьому коді залишаються в стеку. Додаткові копії даних усередині
байтового зрізу не копіюються.

** Примітки

- Зрізи сході на динамічні масиви зі спеціальною вбудованою функціональністю.
- Є різниця між довжиною та ємністю зрізів, і кожна з них має певну мету.
- Зрізи дозволяють багаторазово "переглядати" один і той самий базовий масив.
- Зрізи можна збільшувати за допомогою вбудованої функції append.

** Додаткові матеріали

- [[https://blog.golang.org/go-slices-usage-and-internals][Go Slices: usage and internals]] - Andrew Gerrand    
- [[https://blog.golang.org/strings][Strings, bytes, runes and characters in Go]] - Rob Pike    
- [[https://blog.golang.org/slices][Arrays, slices (and strings): The mechanics of 'append']] - Rob Pike        
- [[https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html][Understanding Slices in Go Programming]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/08/collections-of-unknown-length-in-go.html][Collections Of Unknown Length in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html][Iterating Over Slices In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/slices-of-slices-of-slices-in-go.html][Slices of Slices of Slices in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/12/three-index-slices-in-go-12.html][Three-Index Slices in Go 1.2]] - William Kennedy    
- [[https://github.com/golang/go/wiki/SliceTricks][SliceTricks]]    
- [[https://go-review.googlesource.com/c/go/+/347917][runtime: Make slice growth formula a bit smoother]] - Go Team 
			 
* Вправи

Скористайтеся шаблоном як відправною точкою для виконання вправ. Можливе рішення надається.

** Вправа 1

*Частина* *A:* Оголосіть нульовий зріз цілих чисел. Створіть цикл, який додає 10 значень
до зрізу. Переберіть зріз і відобразіть кожне значення.

*Частина* *B:* Оголосіть зріз із п’яти рядків та ініціалізуйте зріз зі значеннями
рядкового літералу. Відобразіть всі елементи. Візьміть зріз з індексом один і два та
відобразіть позицію індексу та значення кожного елемента в новому зрізі.

.play slices/exercise1.go		  
.play slices/answer1.go
