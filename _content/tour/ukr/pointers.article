Вказівники
Вказівники потрібні щоб ділитися значеннями у межах програми.

* Вказівники

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуй [[https://www.ardanlabs.com/scholarship/][формy для отримання стипендії]]

Вказівники потрібні щоб ділитися значеннями у межах програми. Всього є декілька різних меж програми.
Найбільш розповсюджена - між викликами функцій.
Також існує межа між горутинами, але про неї поговоримо трошки згодом.

** Ревʼю коду

- *Приклад* *1:* Передача за значенням
- *Приклад* *2:* Ділимось даними I
- *Приклад* *3:* Ділимось даними II
- *Приклад* *4:* Аналіз втечі
- *Приклад* *5:* Ріст стеку

.play pointers/example1.go
.play pointers/example2.go
.play pointers/example3.go
.play pointers/example4.go
.play pointers/example5.go

Коли Go програма стартує, Go runtime створює горутину (goroutine). Горутини
це легкі потоки на рівні застосунку, з такою ж семантикою як у потоків операційної системи.
Їх робота полягає в тому, щоб керувати виконанням окремого набору інструкцій.
Кожна Go програма має хоча б одну горутину, яка називається головною.

Кожна горутина має свою власну ділянку памʼяті, яка називається стек (stack). Кожен стек починається з виділення памʼяті розміром 2048 байт (2k).
Це дуже малий розмір, проте стек може збільшитися з часом.

.image /tour/eng/static/img/p1.png

Кожен раз, коли ми викликаємо якусь функцію, їй виділяється частина стека, щоб допомогти горутині виконати інструкції, закладені в цю функцію.
Кожна незалежна частина памʼяті в стеку називається фрейм (frame).

Розмір фрейму для кожної функції вираховується під час компіляції. Значення може бути створено в стеку,
тільки якщо компілятор знає його розмір під час компіляції.
Якщо компілятор під час компіляції не знає розмір значення, то воно створюється у кучі (heap).
 
Стеки самоочищаються, і нульове значення допомагає з ініціалізацією стека.
Кожен раз, коли ми викликаємо функцію, і фрейм памʼяті заблокований, то памʼять для
цього фрейму ініціалізується, що і є самоочищенням стеку. Коли функція завершує виконання, памʼять для фрейму забувається,
бо невідомо чи ця памʼять ще буде знову потрібна. Ініціалізувати памʼять при завершенні виконання функції було б неефективно.

*Передача* *за* *значенням*

Усі дані в програмі передаються за значенням. Це значить, що при передачі даних між межами програми, будь яка функція, 
чи горутина має власну копію цих даних. Є два типа даних, з яким вам прийдеться працювати, самі значення (int,
string, user) або адреса значення. Адреси це теж дані, які копіюються і зберігаються у межах програми.

Наступний код пояснює це детальніше.

    func main() {

        // Визначаємо змінну з типом int і значенням 10.
        count := 10

        // Щоб отримати адресу значення, використовуємо & оператор.
        println("count:\tЗначення[", count, "]\tАдреса[", &count, "]")

        // Передаємо копію "значення" змінної count (що в коробці)
        // у функцію increment1.
        increment1(count)

        // Виводимо на екран "значення" та "адресу" змінної count.
        // Значення count не зміниться після виклику функції.
        println("count:\tЗначення[", count, "]\tАдреса[", &count, "]")

        // Передаємо копію "адреси" змінної count (де коробка)
        // у функцію increment2. Це все ще вважається передачею за значенням,
        // а не передачею за вказівником, тому що адреси це теж значення
        increment2(&count)

        // Виводимо на екран "значення" та "адресу" змінної count.
        // Значення count змінилося після виклику функції.
        println(
            "count:\tЗначення[", 
            count, "]\tАдреса[", &count, "]")
    }

    // increment1 це функція, яка приймає свою власну копію
    // цілочислового значення.
    func increment1(inc int) {

        // Збільшуємо локальну копію цілочислового значення з функції caller.
        inc++
        println("inc1:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
    }

    // increment2 це функція, яка приймає свою власну копію
    // адреси, яка вказує на цілочислове значення.
    // Змінні-вказівники є літеральними типами та оголошуються за допомогою *.
    func increment2(inc *int) {

        // Збільшуємо цілочисловe значення з функції caller через вказівник.
        *inc++
        println(
            "inc2:\tЗначення[", 
            inc, "]\tАдреса[", &inc, 
            "]\tВказує на[", *inc, "]")
    }

Вивід:

    count:  Значення[ 10 ]  Адреса[ 0xc000050738 ]
    inc1:   Значення[ 11 ]  Адреса[ 0xc000050730 ]
    count:  Значення[ 10 ]  Адреса[ 0xc000050738 ]
    inc2:   Значення[ 0xc000050738 ] Адреса[ 0xc000050748 ] Вказує на [ 11 ]
    count:  Значення[ 11 ]  Адреса[ 0xc000050738 ]

** Примітки

- Використовуй вказівники, щоб ділитися даними.
- Значення в Go завжди передаються за значенням.
- "Значення", це те, що в коробці. "Адреса" ( & ), значить де ця коробка.
- Оператор ( * ) визначає змінну-вказівник і "Значення, куди цей вказівник вказує".

** Аналіз втечі (escape analysis)

Алгоритм компілятора, щоб визначити, чи треба змінну створювати у стеку чи кучі,
називається "аналіз втечі" (escape analysis). Імʼя алгоритма звучить так,
ніби змінні спочатку створюються у стеку і потім втікають у кучу, коли це потрібно.  
Це НЕ ПРАВДА. Створення значення відбувається тільки один раз
і алгоритм аналізу втечі визначає де ця зміна буде створена (стек або куча).
Тільки створення змінної у кучі називається виділенням памʼяті (allocation) у Go.

Щоб зрозуміти аналіз втечі треба зрозуміти володіння значенням. Суть у тому,
що якщо значення створюється в межах області видимості функції, тоді ця функція володіє значенням.
Звідси постає питання, чи новостворене значення повинно існувати після завершення виконання функції?
Якщо відповідь ні, то значення створюється у стеку. Якщо відповідь так, то значення створюється у кучі.

Примітка: Правило володіння добре допомагає визначити код який провокує
виділення памʼяті. Проте, майте на увазі, що аналіз втечі містить свої недоліки, які можуть
обернутися неочевидними виділеннями памʼяті. Також, алгоритм не втрачає можливості використати
оптимізації компілятора щоб зекономити на виділеннях памʼяті.

    // user предсталяє користувача в системі.
    type user struct {
        name  string
        email string
    }

    func stayOnStack() user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return u
    }

Функція stayOnStack використовує семантику значення щоб повернути результат з функції.
Іншими словами, той хто викликає функцію, отримує свою власну копію створенного значення.

Коли функція stayOnStack викликається і закінчує виконання, значення user, яке
вона створює, більше не потрібно, тому що той, хто викликав функцію, отримав свою власну копію значення.
З цього слідує, що створення значення user усередені функції stayOnStack відбувається у стеку.
Виділення памʼяті відсутні.

    type user struct {
        name  string
        email string
    }

    func escapeToHeap() *user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return &u
    }

Функція escapeToHeap використовує семантику вказівника щоб повернути значення user назад.
Іншими словами, той хто викликав функцію, отримує спільний доступ до новостворенного значення user.

Коли функція escapeToHeap викликається і завершує виконання, значенню user, яке вона створює,
все ще потрібно існувати, тому що на стороні виклику ми отримуємо спільний доступ до цього значення.
Саме тому значення user усередині escapeToHeap не може буде створено у стеку, воно зобовʼязано
створитися у кучі. І так, це виділення памʼяті.

Подумайте, що б сталося, якби значення user в останньому прикладі було створено
в стеку, використовуючи семантіку вказівника для повернення значення.

.image /tour/eng/static/img/p2.png

Той хто викликає, отримав би копію адреси з стеку, з фрейма, який знаходиться нижче, і цілісність
була б втрачена. Коли контроль повертається до функції, яка викликає, памʼять в стеку, де визначено
значення user, cтає знову можливою для повторного використання. У той момент, коли функція, яка викликає,
зробить виклик іншої функції, новий фрейм визначиться, і памʼять буде перетерта, втративши спільне значення.

Саме тому стек і є самоочисним. Ініціалізація з нульовим значенням допомагає
кожному фрейму стека, який вам потрібен, очиститись без використання збірника сміття.
Стек самоочищається, тому що фрейм береться і ініціалізується для виконання кожного виклику функції.
Стек очищається протягом виклику функції, а не на повернені значення з функції, тому що компілятор не знає
чи буде памʼять у стеку ще знову потрібна.

Аналіз втечі вирішує чи треба створювати значення у стеку (за замовчуванням) чи в кучі (втеча).
У функції stayOnStack ми передаємо копію значення до того хто викликав функцію, тому створювати
це значення в стеку безпечно. У функції escapeToHeap ми передаємо копію адреси значення назад тому,
хто викликає (ділимося значенням по стеку), тому створювати таке значення у стеку небезпечно.

Є ще багато дрібних деталей стосовно аналізу втечі, тому якщо хочете дізнатися більше, то прочитайте додаток
у главі 14, яка називається Механіки аналізу втечі.

Примітка: Починаючи з версії 1.17, Go змінив ABI (application binary interface), щоб
імплементувати новий спосіб передання у функцію вхідних параметрів та отримання вихідних, 
використовуючи регістри, замість памʼяті в стеку. Ця поведінка ввімкнена для Linux, MacOS і Windows
на 64-бітній та x86 архітектурах процесора. Це значить, що деякі аргументи функцій не будуть скопійовані
у стек, проте деякі все-таки можуть бути скопійовані, залежно від доцільності використання регістрів.
Проте, це не міняє жодну з семантик описаних у цій главі.

** Памʼять виділяється в кучі

- Коли на значення можуть посилатися після завершення виконання функції, в якій було створено це значення.
- Коли компілятор розуміє що значення занадто велике, щоб вміститися в стеку.
- Коли компілятор не знає розмір значення під час компіляції.
- Коли значення відокремлено через використання типів інтерфейсів або функцій.

** Семантика збірника сміття (Garbage Collection)

Коли значення створюється в кучі, збірник сміття вимушений долучатися.
Найголовніша частина збірника сміття це алгоритм темпу. Він визначає частоту/темп
з яким збірник сміття виконується, щоб підтримувати найменшу кількість значень у кучі, разом 
з тим зберігати найкращу пропускну здатність програми.

- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection Semantics Part I]] - William Kennedy

** Стек або куча

"Стек потрібен для даних, яким потрібно зберігатися тільки протягом життєвого циклу функції,
яка їх створює, і очищатися без жодних витрат, коли функція завершує виконання. Куча потрібна
для даних, яким потрібно зберігатися навіть після завершення виконання функції, в якій вони створилися,
і очищатися дорогим механізмом збірки сміття." - Ayan George

** Збільшення стеку

Розмір кожного фрейму для кожної функції вираховується під час компіляції. Це значить,
що якщо компілятор не знає розмір значення під час компіляції, то значення зобовʼязане
бути створеним в кучі. Наприклад, створення зрізу (slice) вбудованою функцією make
з розміром який базується на змінній.

    b := make([]byte, size) // Памʼять на нижлежачий масив виділяється у кучі.

Go використовує суміжні стеки для управління зростанням і зменшенням стека. 
Як альтернативу, Go міг би використовувати сегментовані стеки, подібно до того, як це реалізовано в деяких 
операційних системах.

Кожен виклик функції йде з невеличкою передмовою, яка питає: "Тобі достатньо місця
в стеку для нового фрейму?". Якщо так, тоді без проблем береться і ініціалізується новий фрейм.
Якщо ні, то більший стек створюється і памʼять поточного стеку копіюється в новий. Це вимагає
змін до вказівників, які вказують на адреси змінних в стеку. Переваги суміжної памʼяті та лінійних
обходів з сучасним обладнанням - це недолік ціни копіювання.

Саме через використання суміжних стеків, жодна горутина не можe мати вказівник
на стек іншої горутини. Це було б занадто складно, щоб під час виконання слідкувати
за кожним вказівником до кожного стеку, і коректувати ці вказівники до нової локації.

** Додаткові матеріали

*Механіка* *роботи* *вказівників*

- [[https://golang.org/doc/effective_go.html#pointers_vs_values][Pointers vs. Values]]    
- [[https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html][Language Mechanics On Stacks And Pointers]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2014/12/using-pointers-in-go.html][Using Pointers In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/understanding-pointers-and-memory.html][Understanding Pointers and Memory Allocation]] - William Kennedy    

*Стек*

- [[https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub][Contiguous Stack Proposal]]  

*Аналіз* *втечі* *та* *вбудови*

- [[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw][Go Escape Analysis Flaws]]  
- [[https://github.com/golang/go/wiki/CompilerOptimizations][Compiler Optimizations]]

*Збірка* *сміття*

- [[http://gchandbook.org/][The Garbage Collection Handbook]]  
- [[https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md][GC Pacer Redesign - 2021]] - Michael Knyszek  
- [[https://en.wikipedia.org/wiki/Tracing_garbage_collection][Tracing Garbage Collection]]  
- [[https://blog.golang.org/go15gc][Go Blog - 1.5 GC]] 
- [[https://www.youtube.com/watch?v=aiv1JOfMjm0&index=16&list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm][Go GC: Solving the Latency Problem]]  
- [[http://rubinius.com/2013/06/22/concurrent-garbage-collection][Concurrent garbage collection]]  
- [[https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit][Go 1.5 concurrent garbage collector pacing]]  
- [[https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md][Eliminating Stack Re-Scanning]]  
- [[https://groups.google.com/forum/m/#!topic/golang-nuts/KJiyv2mV2pU][Why golang garbage-collector not implement Generational and Compact gc?]] - Ian Lance Taylor  
- [[https://blog.golang.org/ismmkeynote][Getting to Go: The Journey of Go's Garbage Collector]] - Rick Hudson  
- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection In Go : Part I - Semantics]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html][Garbage Collection In Go : Part II - GC Traces]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html][Garbage Collection In Go : Part III - GC Pacing]] - William Kennedy  
- [[https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/][Go memory ballast: How I learnt to stop worrying and love the heap]] - Ross Engers  

*Оптимізація* *статичного* *одиничного* *призначення*

- [[https://www.youtube.com/watch?v=D2-gaMvWfQY][GopherCon 2015: Ben Johnson - Static Code Analysis Using SSA]]  
- [[https://godoc.org/golang.org/x/tools/go/ssa][Package SSA]]    
- [[https://www.youtube.com/watch?v=FnGCDLhaxKU][Understanding Compiler Optimization]]

* Вправи

Використовуй шаблони як стартову точку для виконання вправ. Можливе рішення також надано.

** Вправа 1

*Частина* *A:* Визнач і проініціалізуй змінну з типом int і значенням 20. 
Виведи на екран "адресу" та "значення" змінної.

*Частина* *B:* Визнач і проініціалізуй змінну-вказівник з типом int, яка вказує 
на змінну, яки ти тільки що створив. Виведи на екран "адресу", "значення" змінної та "значення на яке вказівник вказує".
 
** Вправа 2

Визнач структуру і створи змінну цього типа. Визнач функцію, яка може змінювати значення
якогось поля в цій структурі. Виведи на екран значення до і після виклику цієї функції.

.play pointers/exercise1.go
.play pointers/answer1.go
.play pointers/exercise2.go
.play pointers/answer2.go
