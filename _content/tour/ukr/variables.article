Змінні (Variables)
Змінні є основою мови програмування і забезпечують можливість читання з пам’яті та запису в пам’ять.

* Змінні

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][формy для отримання стипендії]]

Змінні є основою мови програмування і забезпечують можливість читання з
пам’яті та запису в пам’ять. У Go, доступ до пам'яті є типобезпечним. Це означає, що компілятор
серйозно ставиться до типів і не дозволить нам використовувати змінні за межами того як
вони були оголошені.

** Перегляд коду

- *Example* *1*: Приклад програми, що показує як оголошувати змінні.

.play variables/example1.go

** Вбудовані типи
Типи забезпечують цілісність і читабельність, задаючи 2 питання:

- Яку кількість пам'яті виділити? (напр. 1, 2, 4, 8 байтів)
- Що відображає ця пам'ять? (напр. int, uint, bool,..)

Типи можуть мати специфічну точність, такі як int32 або int64:

- uint8 представляє ціле число без знаку з 1 байтом виділення
- int32 представляє ціле число зі знаком із 4 байтами виділення. Коли ви декларуєте тип
використовуючи чисельний тип без знаку (unit, int), розмір значання визначається на
основі архітектури, що буде використана при компіляції програми:

- 32-бітова архітектура: представляє ціле число зі знаком із 4 байтами виділення пам'яті
- 64-бітова архітектура: представляє ціле число зі знаком із 8 байтами виділення пам'яті

** Розмір слова

Розмір слова представляє обсяг виділеної пам'яті, необхідний для зберігання цілих чисел
і вказівники для заданої архітектури. Наприклад:

- 32-бітова архітектура: розмір слова становить 4 байти виділення пам'яті
- 64-бітова архітектура: розмір слова становить 8 байтів виділення пам'яті

Це важливо, оскільки Go має внутрішні структури даних (мапи, канали, зрізи,
інтерфейси, ти функції) які зберігають числа і вказівники. Розмір цих структур
даних буде заснований на архітектурі, що буде використана при компіляції програми.

У Go, обсяг пам'яті, виділеної для значення типу int, покажчика або слова
завжди буде однаковим на одній і тій самій архітектурі.

** Концепція нульового значення
Кожне значення, яке ви створюєте в Go, ініціалізується принаймні до стану нульового значення
якщо ви не вкажете значення ініціалізації під час створення. Нульове значення є визначенням
кожного біта в кожному байті до нуля.

Це робиться для збереження цілісності даних і не є безкоштовним. Доводиться витрачати машинний час,
щоб скинути значення бітів до нуля, проте цілісність важливіша за
продуктивність.

    Type               Zero Value
    Boolean            false
    Integer            0
    Float              0
    Complex            0i
    String             "" (empty)
    Pointer            nil

** Оголошення та ініціалізація
Ключове слово var можна використовувати для створення значень у їх нульовому стані для всіх типів.

    var a int
    var b string
    var c float64
    var d bool

    fmt.Printf("var a int \t %T [%v]\n", a, a)
    fmt.Printf("var b string \t %T [%v]\n", b, b)
    fmt.Printf("var c float64 \t %T [%v]\n", c, c)
    fmt.Printf("var d bool \t %T [%v]\n\n", d, d)

Вивід:

    var a int    	int [0]
    var b string 	string []
    var c float64	float64 [0]
    var d bool   	bool [false]

Рядки (strings) використовують набір символів UTF8, але насправді це просто набір байтів.

Рядок — це внутрішня структура даних із двох слів у Go:

- Перше слово представляє вказівник на резервний масив байтів
- Друге слово представляє довжину або кількість байтів у резервному масиві
- Якщо для рядка встановлено нульове значення, то перше слово буде мати значення nil, а
друге слово 0.

Використовуючи короткий оператор оголошення змінної, ви можете оголошувати, створювати та
ініціалізувати значення одночасно.

    aa := 10       // int [10]
    bb := "привіт"  // string [hello]
    cc := 3.14159  // float64 [3.14159]
    dd := true     // bool [true]

    fmt.Printf("aa := 10 \t %T [%v]\n", aa, aa)
    fmt.Printf("bb := \"привіт\" \t %T [%v]\n", bb, bb)
    fmt.Printf("cc := 3.14159 \t %T [%v]\n", cc, cc)
    fmt.Printf("dd := true \t %T [%v]\n\n", dd, dd)

Вивід:

    aa := 10         int [10]
    bb := "привіт"   string [привіт]
    cc := 3.14159    float64 [3.14159]
    dd := true       bool [true]

** Приведення проти кастингу (Conversion vs Casting)

Go не має кастингу, проте має приведення. Замість того, щоб просити компілятор відобразити
набір байтів у іншому представленні, байти потрібно скопіювати в нове
розташування пам'яті для нового представлення.

    aaa := int32(10)
    fmt.Printf("aaa := int32(10) %T [%v]\n", aaa, aaa)

    Output:
    aaa := int32(10) int32 [10]

У стандартній бібліотеці Go є пакет, який називається unsafe, якщо вам дійсно потрібно виконати
операцію кастунгу. Вам краще слід уникати цього і бути чесним із самим собою
щодо того, чи ви збираєтеся його використовувати. Виконання приведення типів забезпечує найвищий рівень
цілісності для цих типів операцій.

** Примітки

- Метою всіх програм і всіх частин цих програм є перетворення даних з однієї форми в іншу.
- Код переважно виділяє, читає та пише в пам’ять.
- Розуміння типу є вирішальним для написання гарного коду та розуміння коду.
- Якщо ви не розумієте даних, ви не розумієте проблеми.
- Ви краще розумієте проблему, розуміючи дані.
- Коли змінним оголошується нульове значення, використовуйте ключове слово var.
- Коли змінні оголошуються та ініціалізуються, використовуйте короткий оператор оголошення змінних.

** Додаткові матеріали

- [[http://golang.org/ref/spec#Boolean_types][Built-In Types]]    
- [[https://golang.org/doc/effective_go.html#variables][Variables]]    
- [[https://www.ardanlabs.com/blog/2013/08/gustavos-ieee-754-brain-teaser.html][Gustavo's IEEE-754 Brain Teaser]] - William Kennedy    
- [[https://www.youtube.com/watch?v=sFUSP8Au_PE][What's in a name]]    
- [[http://arcanesentiment.blogspot.com/2015/01/a-brief-history-of-type.html][A brief history of “type”]] - Arcane Sentiment    

* Вправи

Скористайтеся шаблоном як відправною точкою для виконання вправ. Можливе рішення надається.

** Вправа 1

*Частина* *A:* Оголосіть три змінні, які ініціалізуються нульовим значенням і
три оголошені з літеральним значенням. Оголошення змінних типу string, int і bool.
Відобразіть значення цих змінних.

*Частина* *B:* Оголосіть нову змінну типу float32 та ініціалізуйте її за допомогою
перетворення літерального значення Пі (3.14).

.play variables/exercise1.go
.play variables/answer1.go
