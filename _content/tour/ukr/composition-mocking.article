Імітування (Mocking)
Оскільки компілятор має змогу виконувати стватичний аналіз коду, щоб визначити чи конкретне значення імплементує інтерфейс, розробник, що оголошує конкретний тип, також може не надавати інтерфейси.  

* Імітування (Mocking)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][форму для отримання стипендії]]

Найкрашій спосіб скористатися перевагами встраювання(embedding) 
полягає у використанні композиційного шаблону проєктування. Ідея полягає у тому щоб складати більш великі типи з меньших типів
та фокусуватися на композиції поведінки.

** Перегляд коду

- *Приклад* *1:* Імітування

.play composition/mocking/example1.go

** Володіння Інтерфейсом(Interface Ownership)

Одною з речей, які відрізняють Go від інших мов програмування,
є ідея договору понад конфігурацією. Ця особливо чітко проявляється у тому, як Go обробляє відповідність до інтерфейсу.
Через те що компілятор має змогу провести статичний аналіз коду, щоб визначити чи імплементує конретне значення інтерфейс,
розробник, що оголошує конкретний тип, також не має надавати інтерфейс.

    package pubsub
    
    type PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // PRETEND THERE IS A SPECIFIC IMPLEMENTATION.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // PRETEND THERE IS A SPECIFIC IMPLEMENTATION.
        return nil
    }

You've just implemented a new API that provides a concrete implementation for publish
and subscribe. There are no interfaces being provided because this API does not
need one. This is a single concrete implementation.

What if the application developer wanting to use this new API needs an interface
because they have the need to mock this implementation during tests? In Go, that
developer can declare the interface and the compiler can identify the compliance.

    package main

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    type mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // ADD MY MOCK FOR THE PUBLISH CALL.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // ADD MY MOCK FOR THE SUBSCRIBE CALL.
        return nil
    }

This code in the main package is declaring an interface. This interface represents
the API that the application is using from the pubsub package. The developer has
implemented their own pubsub implementation for testing. The key here is that this
application developer doesn’t use any concrete implementation directly, but decouples
themselves through their own interface.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("key", "value")
            p.Subscribe("key")
        }
    }

To provide an example, the main function constructs a collection that is initialized
with the pubsub implementation and the mock implementation. The publisher interface
allows this. Then a for range loop is implemented to show how the application code
is abstracted from any concrete implementation.
