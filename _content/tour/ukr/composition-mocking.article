Імітування (Mocking)
Оскільки компілятор має змогу виконувати стватичний аналіз коду, щоб визначити чи конкретне значення імплементує інтерфейс, розробник, що оголошує конкретний тип, також може не надавати інтерфейси.  

* Імітування (Mocking)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][форму для отримання стипендії]]

Найкрашій спосіб скористатися перевагами встраювання(embedding) 
полягає у використанні композиційного шаблону проєктування. Ідея полягає у тому щоб складати більш великі типи з меньших типів
та фокусуватися на композиції поведінки.

** Перегляд коду

- *Приклад* *1:* Імітування

.play composition/mocking/example1.go

** Володіння Інтерфейсом(Interface Ownership)

Одною з речей, які відрізняють Go від інших мов програмування,
є ідея договору понад конфігурацією. Ця особливо чітко проявляється у тому, 
як Go обробляє відповідність до інтерфейсу. Через те, що компілятор має змогу провести статичний аналіз коду,
щоб визначити чи конретне значення імплементує інтерфейс,
розробник, що оголошує конкретний тип, також не має надавати інтерфейс.

    package pubsub
    
    type PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // УЯВІМО, ЩО ТУТ Є ПЕВНА ІМПЛЕМЕНТАЦІЯ.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // УЯВІМО, ЩО ТУТ Є ПЕВНА ІМПЛЕМЕНТАЦІЯ.
        return nil
    }

Ви щойно імплементували новий API, який надає конкретну імплементацію для публікації(publish)
та підписки(subscribe). Тут не було надано жодного інтерфейсу, оскільки цей API їх не потребує.
Це єдина конретна імплементація.

Що як розробник програми, що бажає використати цей новий API, потребує інтерфейс,
тому що в нього є потреба імітувати імплементацію під час тестів? В Go, цей розробник
може оголосити інтерфейс, а компілятор ідентифікує відповідність до цього інтерфейсу.

    package main

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    type mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // ДОДАЙТЕ ІМІТАЦІЮ ДЛЯ ВИКЛИКУ PUBLISH.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // ДОДАЙТЕ ІМІТАЦІЮ ДЛЯ ВИКЛИКУ SUBSCRIBE.
        return nil
    }

Цей код в пакунку main декларує інтерфейс. Цей інтерфейс представляє API,
який використовує програму з пакунку pubsub. Розробник створив
свою власну імплементацію pubsub для тестування. Ключовий момент полягає в тому,
що розробник програми не використовує жодної конкретної імплементації напряму, 
відокремлюючи себе через свої ж інтерфейси.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("key", "value")
            p.Subscribe("key")
        }
    }

Для прикладу, функція main створює колекцію, яка ініційована
імплементацією pubsub та імітацією. Інтерфейс publisher це дозволяє.
Потім імплементовано цикл for range, щоб показати як код програми
абстраговано від будь якої конкретної імплементації.
