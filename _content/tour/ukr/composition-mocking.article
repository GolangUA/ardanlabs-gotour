Імітування (Mocking)
Оскільки компілятор має змогу виконувати статичний аналіз коду, щоб визначити, чи конкретне значення реалізує інтерфейс, розробник, що оголошує конкретний тип, також може не надавати інтерфейси.

* Імітування

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][форму для отримання стипендії]]

Найкраший спосіб скористатися перевагами вбудовування (embedding) 
полягає у використанні композиційного шаблону проєктування. Ідея полягає у тому, щоб складати більш великі типи з менших типів
та фокусуватися на композиції поведінки.

** Перегляд коду

- *Приклад* *1:* Імітування

.play composition/mocking/example1.go

** Володіння Інтерфейсом (Interface Ownership)

Одною з речей, які відрізняють Go від інших мов програмування,
є ідея контракту понад конфігурацією. Це особливо чітко проявляється у тому, 
як Go обробляє відповідність до інтерфейсу. Компілятор має змогу самостійно провести статичний аналіз коду,
та визначити який інтерфейс реалізує конкретне тип, тому
розробник, що оголошує цей конкретний тип, має можливість не надавати жодних інтерфейсів.

    package pubsub
    
    type PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // УЯВІМО, ЩО ТУТ Є ПЕВНА РЕАЛІЗАЦІЯ.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // УЯВІМО, ЩО ТУТ Є ПЕВНА РЕАЛІЗАЦІЯ.
        return nil
    }

Ви щойно створили новий API, який надає конкретну реалізацію для публікації (publish)
та підписки (subscribe). Тут не було надано жодного інтерфейсу, оскільки цей API їх не потребує.
Це єдина конкретна реалізація.

Що як розробник програми, що бажає використати цей новий API, потребує інтерфейс,
тому що в нього є потреба імітувати реалізацію під час тестів? В Go, цей розробник
може оголосити інтерфейс, а компілятор ідентифікує відповідність до цього інтерфейсу.

    package main

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    type mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // ДОДАЙТЕ ІМІТАЦІЮ ДЛЯ ВИКЛИКУ PUBLISH.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // ДОДАЙТЕ ІМІТАЦІЮ ДЛЯ ВИКЛИКУ SUBSCRIBE.
        return nil
    }

Цей код в пакеті main декларує інтерфейс. Цей інтерфейс представляє API,
який використовує програму з пакету pubsub. Розробник створив
свою власну реалізацію pubsub для тестування. Ключовий момент полягає в тому,
що розробник програми не використовує жодної конкретної реалізації напряму,
відокремлюючи себе через свої ж інтерфейси.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("key", "value")
            p.Subscribe("key")
        }
    }

Для прикладу, функція main створює колекцію, яка ініціюється
реалізацією pubsub та імітацією. Інтерфейс publisher це дозволяє.
Потім реалізовано цикл for range, щоб показати як код програми
абстраговано від будь-якої конкретної реалізації.
