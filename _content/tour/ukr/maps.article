Мапи (Maps)
Мапа це структура даних, яка забезпечує зберігання та доступ до даних на основі ключа.

* Мапи

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Дивитись відео]]
- Якщо потрібна фінансова допомога, то використовуйте [[https://www.ardanlabs.com/scholarship/][формy для отримання стипендії]]

Мапа це структура даних, яка забезпечує підтримку зберігання та доступу до даних
на основі ключа. Вона використовує хеш-мапу та систему бакетів, яка під капотом підтримує
безперервний блок пам'яті.

** Перегляд коду

- *Приклад* *1:* Оголошення, запис, читання, та видалення
- *Приклад* *2:* Відсутні ключі
- *Приклад* *3:* Обмеження ключів мапи
- *Приклад* *4:* Літерали та діапазон мап
- *Приклад* *5:* Сортування мап за ключем
- *Приклад* *6:* Отримання адреси елемента
- *Приклад* *7:* Мапи є типом посилання

.play maps/example1.go
.play maps/example2.go
.play maps/example3.go
.play maps/example4.go
.play maps/example5.go
.play maps/example6.go
.play maps/example7.go

** Оголошення і створення мап

Оголосити та створити мапу можна декількома способами.

    type user struct {
        name     string
        username string
    }

    // Створення мапи з нульовим значенням,
    // що може зберігати значення користувачів із ключем рядкового типу.
    // Спроба використати цю мапу призведе до помилки виконання (паніки).
    var users map[string]user

    // Створення мапи за допомогою функції make,
    // що може зберігати значення користувачів із ключем рядкового типу.
    users := make(map[string]user)

    // Створення мапи за допомогою пустої літеральної конструкції,
    // що може зберігати значення користувачів із ключем рядкового типу.
    users := map[string]user{}

Мапа, ініціалізована нульовим значенням, не придатна для використання і призведе до паніки в програмі.
Використання вбудованої функції make або літеральної конструкції створює мапу,
готову до використання.

    func main() {
        users := make(map[string]user)

        users["Roy"] = user{"Rob", "Roy"}
        users["Ford"] = user{"Henry", "Ford"}
        users["Mouse"] = user{"Mickey", "Mouse"}
        users["Jackson"] = user{"Michael", "Jackson"}

        for key, value := range users {
            fmt.Println(key, value)
        }
    }

Вивід:

    Roy {Rob Roy}
    Ford {Henry Ford}
    Mouse {Mickey Mouse}
    Jackson {Michael Jackson}

Якщо вбудована функція make використовується для створення мапи, тоді оператор присвоєння
можна використовувати для додавання та оновлення значень у мапі. Порядок, у якому ключі/значення
повертаються при ітерації по мапі, не визначений специфікацією і залежить від реалізації
компілятора.

    func main() {
        users := map[string]user{
            "Roy":     {"Rob", "Roy"},
            "Ford":    {"Henry", "Ford"},
            "Mouse":   {"Mickey", "Mouse"},
            "Jackson": {"Michael", "Jackson"},
        }

        for key, value := range users {
            fmt.Println(key, value)
        }
    }

Вивід:

    Ford {Henry Ford}
    Jackson {Michael Jackson}
    Roy {Rob Roy}
    Mouse {Mickey Mouse}

У цьому випадку вивід був повернений у порядку, відмінному від того, як вони
вказані при створенні. Поточний алгоритм для версії 1.16 поверне результати
в випадковому порядку, як тільки кількість значень досягне певного ліміту. Це знову ж таки
реалізація компілятора, яка може змінюватися. Ви на це не можете покладатися.

** Пошук і видалення ключів мапи

Як тільки дані збережені в мапі, для вилучення будь-яких даних необхідний пошук за ключем.

    user1, exists1 := users["Bill"]
    user2, exists2 := users["Ford"]

    fmt.Println("Bill:", exists1, user1)
    fmt.Println("Ford:", exists2, user2)

Вивід:

    Bill: false { }
    Ford: true {Henry Ford}

Для виконання пошуку за ключем використовуються квадратні дужки зі змінною мапи. З
пошуку в мапі можуть бути повернені два значення: значення та булеве значення, яке вказує,
чи було знайдено значення. Якщо вам не потрібно знати це, ви можете не використовувати
змінну exists.

Коли ключ в мапі не знайдено, операція повертає значення типу мапи,
встановлене в його нульовий стан. Ви можете побачити це при пошуку ключа "Bill". Не використовуйте
нульове значення для визначення, чи існує ключ у мапі, оскільки нульове значення може бути
дійсним і тим, що було фактично збережено для ключа.

    delete(users, "Roy")

Існує вбудована функція під назвою delete, яка дозволяє видаляти дані
з мапи на основі ключа.

** Обмеження ключів мапи

Не всі типи можуть бути використані як ключ.

    type slice []user
    Users := make(map[slice]user)

Помилка компілятора:

    invalid map key type users

Зріз є хорошим прикладом типу, який не можна використати як тип. Тільки значення що
можна пропустити через функцію хешування є прийнятними. Простий спосіб розпізнати типи
що можуть бути ключем, якщо тип можна використати в операції порівняння. Ви не можете
порівняти два значення зрізів.

** Примітки

- Мапи забезпечують спосіб зберігання та отримання пар ключ/значення.
- Читання відсутнього ключа повертає нульове значення для типу значення мапи.
- Ітерація по мапі завжди випадкова.
- Ключ мапи має мати значення, що можна порівняти.
- Елементи у мапі не адресуються.
- Мапи є типом посилання.

** Додаткові матеріали

- [[https://blog.golang.org/go-maps-in-action][Go maps in action]] - Andrew Gerrand    
- [[https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html][Macro View of Map Internals In Go]] - William Kennedy    
- [[https://www.youtube.com/watch?v=Tl7mi9QmLns][Inside the Map Implementation]] - Keith Randall    
- [[https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics][How the Go runtime implements maps efficiently (without generics)]] - Dave Cheney     

* Вправи

Скористайтеся шаблоном як відправною точкою для виконання вправ. Можливе рішення надається.

** Вправа 1

Оголосіть і створіть мапу цілих значень із рядком як ключем. Заповніть мапу
п'ятьма значеннями та переберіть мапу, щоб відобразити пари ключ/значення.

.play maps/exercise1.go
.play maps/answer1.go
