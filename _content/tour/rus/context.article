Пакет Context
Пакет context определяет тип `Context`, который переносит сроки, сигналы отмены и другие значения, связанные с запросами, через границы API и между процессами.

* Пакет Context

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Пакет `context` определяет тип `Context`, который переносит сроки, отмены
сигналы и другие значения, связанные с запросами, через границы API и между процессами.

** Обзор кода

"Значения контекста предназначены для данных, копируемых по запросу, которые проходят через программы в
распределенной системе."

- *Пример* *1:* Хранение/Извлечение значений
- *Пример* *2:* WithCancel
- *Пример* *3:* WithDeadline
- *Пример* *4:* WithTimeout
- *Пример* *5:* Запрос/Ответ
- *Пример* *6:* Отмена

.play context/example1.go
.play context/example2.go
.play context/example3.go
.play context/example4.go
.play context/example5.go
.play context/example6.go

** Семантика контекста

В языке программирования Go есть встроенное ключевое слово `go` для создания горутин, но
не имеет ключевых слов или прямой поддержки для их завершения. В реальных сервисах,
возможность тайм-аута и завершения горутин критически важна для поддержания работоспособности
и функционирования сервиса. Ни один запрос или задача не могут выполняться вечно, поэтому
определение и управление задержками - обязанность каждого программиста.

Решением этой проблемы, предложенным командой Go, является пакет `Context`.
Он был написан и представлен Самиром Аджмани в 2014 году на конференции Gotham Go. 
Он также написал статью в блоге Go.

Слайды: [[https://talks.golang.org/2014/gotham-context.slide#1][https://talks.golang.org/2014/gotham-context.slide#1]]

Заметка в блоге: [[https://blog.golang.org/context][https://blog.golang.org/context]].

Благодаря этим публикациям и беседам с Самиром на протяжении многих лет,
сформировался набор семантики.

*Входящие* *запросы* *на* *сервер* *должны* *создавать* *контекст*.

Время для создания контекста - всегда как можно раньше в процессе обработки
запроса или задачи. Работа с контекстом на ранних этапах разработки заставит вас
разрабатывать API так, чтобы в качестве первого параметра принимался контекст. Даже если вы не уверены на 100 %.
уверены, что функции нужен Context, проще убрать Context из нескольких
функций, чем пытаться добавить контекст позже.

    75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
    76 // pair, this makes for really easy, convenient routing.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    ...
    85     // The function to execute for each request.
    86     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    87         ctx, span := trace.StartSpan(r.Context(), "internal.platform.web")
    88         defer span.End()
    ...
    106    // Add this handler for the specified verb and route.
    107    a.TreeMux.Handle(verb, path, h)
    108 }

Вы видите код, взятый из `service` проекта, который мы преподаем в Ardan Labs. В строке 86 определена
функцию-обработчик, которая привязывается ко всем маршрутам, как показано в строке 107. Именно эта
функция начинает обрабатывать все входящие запросы. В строке 87 создается `span`
для запроса, который принимает в качестве первого параметра `Context`. Это первый
раз когда в коде сервиса требуется `Context`.

Заметьте, что значение `http.Request` уже содержит `Context`. Это
было добавлено в версии 1.7 Go. Это означает, что коду не нужно вручную создавать
контекст верхнего уровня. Если бы мы использовали версию 1.6 Go, то вам пришлось бы
создать пустой `Context` перед вызовом `StartSpan` с помощью функции `context.Background`.

    https://golang.org/pkg/context/#Background

    87         ctx := context.Background()
    88         ctx, span := trace.StartSpan(ctx, "internal.platform.web")
    89         defer span.End()

Вот как должен выглядеть код в версии 1.6 Go. Как описано
в документации к пакету,

Background возвращает не нулевой, пустой `Context`. Он никогда не отменяется, не имеет значений,
и не имеет срока выполнения. Обычно он используется в главной функции, при инициализации,
и тестах, а также в качестве контекста верхнего уровня для входящих запросов.

Идиома в Go - использовать имя переменной `ctx` для всех значений `Context`. Поскольку
`Context` - это интерфейс, семантика указателей не должна использоваться.

    https://golang.org/pkg/context/#Context

    type Context interface {
        Deadline() (deadline time.Time, ok bool)
        Done() <-chan struct{}
        Err() error
        Value(key interface{}) interface{}
    }

Каждая функция, принимающая контекст, должна получить свою собственную копию значения интерфейса.

*Исходящие* *вызовы* *к* *серверам* *должны* *принимать*  *контекст*.

Идея этой семантики заключается в том, что вызовы более высокого уровня должны сообщать вызовам более низкого уровня
как долго они готовы ждать. Отличным примером этого является пакет `http`
и изменениями версии 1.7, внесенными в метод `Do` для соблюдения тайм-аута при
запроса.

    01 package main
    02 
    03 import (
    04     "context"
    05     "io"
    06     "log"
    07     "net/http"
    08     "os"
    09     "time"
    10 )
    11 
    12 func main() {
    13
    14     // Create a new request.
    15     req, err := http.NewRequest("GET", "https://www.ardanlabs.com/blog/post/index.xml", nil)
    16     if err != nil {
    17         log.Println("ERROR:", err)
    18         return
    19     }
    20
    21     // Create a context with a timeout of 50 milliseconds.
    22     ctx, cancel := context.WithTimeout(req.Context(), 50*time.Millisecond)
    23     defer cancel()
    24
    25     // Bind the new context into the request.
    26     req = req.WithContext(ctx)
    27
    28     // Make the web call and return any error. Do will handle the
    29     // context level timeout.
    30     resp, err := http.DefaultClient.Do(req)
    31     if err != nil {
    32       log.Println("ERROR:", err)
    33       return
    34     }
    35
    36     // Close the response body on the return.
    37     defer resp.Body.Close()
    38
    39     // Write the response to stdout.
    40     io.Copy(os.Stdout, resp.Body)
    41 }

Эта программа отправляет запрос на rss-ленту блога Ardan с тайм-аутом в 50
миллисекунд. В строках 15-19 запрос создается для выполнения `GET`-вызова по
предоставленному `URL`. В строках 22-23 создается контекст с таймаутом 50 миллисекунд. A
Новый `API`, добавленный к значению`Request` еще в версии 1.7, - это метод `WithContext`.
Этот метод позволяет обновлять поле `Context` значения `Request`. В строке 26,
именно это и делает программа.

В строке 30 выполняется фактический запрос с помощью метода `Do` из значения http пакета
`DefaultClient`. Метод `Do` будет соблюдать значение тайм-аута в 50 миллисекунд
которое теперь установлено внутри контекста в значении `Request`. То, что вы видите, - это
код (функция более высокого уровня), сообщающий методу `Do` (функция более низкого уровня), как долго
мы готовы ждать завершения операции `Do`.

*Не* *храните* *`Context`* *внутри* *структуры* *типа*.

Вместо этого передавайте `Context` явно каждой функции, которой он нужен. По сути, любая
функция, выполняющая ввод-вывод, должна принимать значение `Context` в качестве первого параметра
и соблюдать любой таймаут или крайний срок, установленный вызывающей стороной. В случае с `Request`,
необходимо было учитывать вопросы обратной совместимости. Поэтому вместо того, чтобы менять API,
была реализована механика, показанная в последнем разделе.

Из каждого правила есть исключения. Однако в рамках данного поста и любых
API из стандартной библиотеки, которые принимают `Context`, идиома заключается в том, что первый
параметр принимает значение `Context`.

.image /tour/eng/static/img/context_figure1.png

Фрагмент представляет собой пример из пакета net, где первый 
параметр каждого метода принимает `Context` в качестве 
первого параметра и использует идиому с переменной `ctx`.

*Цепь* *вызовов* *функций* *между* *ними* *должна* *передавать* *контекст* *(Context)*

Это важное правило, поскольку контекст (Context) ориентирован на запрос или задачу.
Вы хотите, чтобы контекст (Context) и любые изменения, внесенные в него в процессе выполнения 
запроса или задачи, передавались и учитывались.

    23 // List returns all the existing users in the system.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

На этом фрагменте кода видно функцию-обработчик с именем `List`,
которая выполняется при запросе пользователя через `HTTP` для данной конечной точки.
Обработчик принимает контекст (Context) в качестве первого параметра,
поскольку он является частью запроса и выполняет ввод-вывод.
Как видно на строках 25, 28 и 33, тот же самый контекст (Context) передается вниз по стеку вызовов.

Новый объект контекста (Context) не создается, поскольку для этой функции не требуются изменения.
Если бы новый объект контекста (Context) верхнего уровня был создан этой функцией, 
любая существующая информация о контексте (Context) из вызова более высокого уровня,
связанного с этим запросом, была бы утеряна. Это не то, что вам нужно.

    33 // List retrieves a list of existing users from the database.
    34 func List(ctx context.Context, db *sqlx.DB) ([]User, error) {
    35     ctx, span := trace.StartSpan(ctx, "internal.user.List")
    36     defer span.End()
    37
    38     users := []User{}
    39     const q = `SELECT * FROM users`
    40
    41     if err := db.SelectContext(ctx, &users, q); err != nil {
    42         return nil, errors.Wrap(err, "selecting users")
    43     }
    44
    45     return users, nil
    46 }

Вы видите объявление метода List, который был вызван на строке 28. Еще раз, этот метод
принимает контекст (Context) в качестве своего первого параметра. Затем это значение передается
вниз по стеку вызовов снова на строках 35 и 41. Поскольку строка 41 представляет собой
вызов базы данных, эта функция должна уважать любую установленную в контексте
информацию о тайм-ауте от вызывающего выше.

*Заменяйте* *контекст* *(Context)* *с* *использованием* *`WithCancel`*, *`WithDeadline`*, *`WithTimeout`* *или* *`WithValue`*

Поскольку каждая функция может добавлять/изменять контекст (Context) в соответствии с их
конкретными потребностями, и эти изменения не должны влиять на любую функцию,
которая была вызвана ранее, контекст (Context) использует семантику значений.
Это означает, что любое изменение значения контекста (Context) создает новое значение
контекста (Context), которое затем передается вперед.

    01 func main() {
    02
    03     // Set a duration.
    04     duration := 150 * time.Millisecond
    05
    06     // Create a context that is both manually cancellable and will signal
    07     // cancel at the specified duration.
    08     ctx, cancel := context.WithTimeout(context.Background(), duration)
    09     defer cancel()
    10
    11     // Create a channel to receive a signal that work is done.
    12     ch := make(chan data, 1)
    13
    14     // Ask the goroutine to do some work for us.
    15     go func() {
    16
    17         // Simulate work.
    18         time.Sleep(50 * time.Millisecond)
    19
    20         // Report the work is done.
    21         ch <- data{"123"}
    22     }()
    23
    24     // Wait for the work to finish. If it takes too long, move on.
    25     select {
    26         case d := <-ch:
    27             fmt.Println("work complete", d)
    28
    29         case <-ctx.Done():
    30             fmt.Println("work cancelled")
    31     }
    32 }

Это небольшая программа, которая демонстрирует природу значений в функции `WithTimeout`.
На строке 08 вызов `WithTimeout` возвращает новое значение контекста (Context) и функцию отмены.
Поскольку вызов функции требует родительский контекст (Context),
код использует функцию `Background` для создания пустого контекста (Context) верхнего уровня.
Для этого и предназначена функция `Background`.

Далее используется значение контекста (Context), созданное функцией `WithTimeout`.
Если будущим функциям в цепочке вызовов потребуется свой собственный тайм-аут или крайний срок,
они также должны использовать соответствующую функцию `With` и это новое значение контекста (Context) в качестве родителя.

Крайне важно, чтобы любая функция отмены, возвращаемая функцией `With`, выполнялась до того,
как эта функция возвратится. Поэтому идиома заключается в использовании ключевого слова `defer` 
сразу после вызова `With`, как видно на строке 26. Не выполнение этого действия может привести
к утечкам памяти в вашей программе.

*При* *отмене* *контекста* *(Context)* *все* *контексты*, *производные* *от* *него*, *также* *отменяются*

Использование значений в API контекста (Context) означает, что каждому новому значению 
контекста (Context) передается все, что есть у родительского контекста (Context), 
плюс любые новые изменения. Это означает, что если родительский контекст (Context) отменен, 
все производные от него дочерние контексты (Context) также отменяются.

    01 func main() {
    02
    03     // Create a Context that can be cancelled.
    04     ctx, cancel := context.WithCancel(context.Background())
    05     defer cancel()
    06
    07     // Use the Waitgroup for orchestration.
    08     var wg sync.WaitGroup
    09     wg.Add(10)
    10
    11     // Create ten goroutines that will derive a Context from
    12     // the one created above.
    13     for i := 0; i < 10; i++ {
    14         go func(id int) {
    15             defer wg.Done()
    16
    17             // Derive a new Context for this goroutine from the Context
    18             // owned by the main function.
    19             ctx := context.WithValue(ctx, key, id)
    20
    21             // Wait until the Context is cancelled.
    22             <-ctx.Done()
    23             fmt.Println("Cancelled:", id)
    24         }(i)
    25     }
    26
    27     // Cancel the Context and any derived Context's as well.
    28     cancel()
    29     wg.Wait()
    30 }

Эта программа создает значение контекста (Context), которое может быть отменено на строке 04.
Затем на строках 13-25 создаются десять горутин. Каждая горутина помещает свой уникальный 
идентификатор в свое собственное значение контекста (Context) на строке 19. Вызов `WithValue` 
передает значение контекста (Context) основной функции в качестве родителя. 
Затем на строке 22 каждая горутина ждет, пока ее контекст (Context) не будет отменен.

На строке 28 основная горутина отменяет свое значение контекста (Context) и затем 
ожидает на строке 29, чтобы все десять горутин получили сигнал перед завершением программы. 
Как только вызывается функция отмены, все десять горутин на строке 41 станут разблокированными 
и выведут сообщение, что они были отменены. 
Один вызов функции отмены для отмены всех.

Это также показывает, что один и тот же контекст (Context) может передаваться функциям, 
выполняющимся в разных горутинах. Контекст (Context) безопасен для одновременного использования 
несколькими горутинами.

Не передавайте nil-контекст (Context), даже если функция разрешает его. 
Передавайте контекст (Context) `TODO`, если вы не уверены, какой контекст использовать. 
Одна из моих любимых частей пакета `Context` - это функция `TODO`. Я твердо верю, что программист 
всегда черновик кода. Это ничем не отличается от писателя, который черновит версии статьи. 
Вы никогда не знаете всего, когда пишете код, но, надеюсь, вы знаете достаточно, 
чтобы продвигаться вперед. В конце концов, вы постоянно учитесь, рефакторите и тестируете по пути.

Бывали случаи, когда я знал, что мне нужен контекст (Context), но был неуверен, 
откуда он должен взяться. Я знал, что я несу ответственность за создание контекста (Context) 
верхнего уровня, поэтому использование функции Background было недопустимо. 
Мне нужен был временный контекст (Context) верхнего уровня, пока я не выяснил, 
откуда на самом деле будет браться контекст (Context). В этом случае следует использовать 
функцию TODO вместо функции `Background`.

*Используйте* *значения* *контекста* *(Context)* *только* *для* *данных*, *связанных* *с* *запросом*

Не используйте контекст (Context) для передачи необязательных параметров в функции. 
Это, возможно, самая важная семантика из всех. Не используйте значение контекста (Context) 
для передачи данных в функцию, когда эти данные необходимы функции для успешного выполнения своего кода. 
Другими словами, функция должна иметь возможность выполнить свою логику с пустым значением 
контекста (Context). В случаях, когда для выполнения функции требуется информация в 
контексте (Context), если эта информация отсутствует, программа должна завершиться с сигналом о выключении.

Классическим примером неправильного использования передачи данных в вызов функции с использованием контекста (Context) является работа с подключениями к базе данных. Как общее правило, вы хотите следовать этому порядку при перемещении данных по программе.

1. Передавайте данные в качестве параметра функции. Это самый четкий способ перемещения данных по программе 
без их скрытия.

2. Передавайте данные через получателя. Если функция, которой нужны данные, не может изменить свою сигнатуру, 
используйте метод и передавайте данные через получателя.

Пример использования получателя:

Обработчики запросов - классический пример второго правила. 
Поскольку функция обработчика привязана к конкретному объявлению, сигнатуру обработчика нельзя изменить.

    23 // List returns all the existing users in the system.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

Здесь вы видите метод обработчика `List` из проекта `service`. Сигнатуры этих методов привязаны к тому, 
что определено веб-фреймворком, и их нельзя изменить. Тем не менее, для выполнения бизнес-вызова на строке 28 
требуется подключение к базе данных. Этот код находит пул подключений не из значения контекста (Context), 
переданного внутрь, а из получателя.

    15 // User represents the User API method handler set.
    16 type User struct {
    17     db            *sqlx.DB
    18     authenticator *auth.Authenticator
    19
    20 // ADD OTHER STATE LIKE THE LOGGER AND CONFIG HERE.
    21 }

Вы видите объявление типа получателя. Все, что нужно обработчику запроса, определено как поля. 
Это позволяет информации не скрываться и бизнес-уровню функционировать с пустым значением контекста (Context).



    14 // API constructs an http.Handler with all application routes defined.
    15 func API(shutdown chan os.Signal, log *log.Logger, db *sqlx.DB, authenticator *auth.Authenticator) http.Handler {
    16
    ...
    26     // Register user management and authentication endpoints.
    27     u := User{
    28         db:            db,
    29         authenticator: authenticator,
    30     }
    31
    32     app.Handle("GET", "/v1/users", u.List)

Этот код создает значение `User`, а затем привязывает метод `List` к маршруту. 
Еще раз, поскольку сигнатуру функции обработчика нельзя изменить, использование получателя и 
методов - это следующий лучший способ передачи данных без их скрытия.

*Отладочные* *или* *следящие* *данные* *безопасны* *для* *передачи* *в* *контексте* *(Context)*

Данные, которые могут быть сохранены и получены из значения контекста (Context), 
это информация для отладки и трассировки.

    23 // Values represent state for each request.
    24 type Values struct {
    25     TraceID    string
    26     Now        time.Time
    27     StatusCode int
    28 }

Вот объявление типа, который создается и сохраняется внутри каждого значения контекста (Context), 
созданного для нового запроса. Три поля предоставляют трассировку и отладочную информацию для запроса. 
Эта информация собирается по мере выполнения запроса.

    75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
    76 // pair, this makes for really easy, convenient routing.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    78
    ...
    79     // The function to execute for each request.
    80     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    …
    84     // Set the context with the required values to
    85     // process the request.
    86     v := Values{
    87         TraceID: span.SpanContext().TraceID.String(),
    88         Now:     time.Now(),
    89     }
    90     ctx = context.WithValue(ctx, KeyValues, &v)

Обратите внимание, как тип Values создается на строке 86, а затем сохраняется внутри 
контекста (Context) на строке 90. Большую часть этой информации требует промежуточный уровень логирования.

    20 // Create the handler that will be attached in the middleware chain.
    21 h := func(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    ...
    25     // If the context is missing this value, request the service
    26     // to be shutdown gracefully.
    27     v, ok := ctx.Value(web.KeyValues).(*web.Values)
    28     if !ok {
    29         return web.NewShutdownError("web value missing from context")
    30     }
    ...
    34     log.Printf("%s : (%d) : %s %s -> %s (%s)",
    35         v.TraceID, v.StatusCode,
    36         r.Method, r.URL.Path,
    37         r.RemoteAddr, time.Since(v.Now),
    38     )

Последствия передачи информации через Context показаны в коде на
строках 27-30. Код пытается получить данные `Values` из контекста
и проверяет, были ли эти данные там. Если данных нет, то возникает серьезная проблема целостности
и сервис должен быть остановлен. Это делается в коде сервиса путем
отправкой специального значения ошибки обратно через приложение.

Если вы передаете соединения с базой данных или информацию о пользователе на бизнес
уровень с помощью `Context`, у вас возникает две проблемы:

- Вам нужно проверять достоверность и вам нужен механизм для быстрого завершения работы сервиса.
- Тестирование и отладка становятся намного сложнее и запутаннее. Вы отказываетесь от ясности и читабельности кода.

** Примечания

- Входящие запросы к серверу должны создавать Context.
- Исходящие вызовы к серверам должны принимать Context. 
- Цепочка вызовов функций между ними должна распространять Context.
- Замените Context с помощью `WithCancel`, `WithDeadline`, `WithTimeout` или `WithValue`.
- Когда Context отменяется, все производные от него `Context` также отменяется.
- Не храните `Context` внутри  `struct`; вместо этого передавайте `Context` явно каждой функции, которой он нужен.
- Не передавайте Context с нулевым значением, даже если функция это допускает. Передавайте `context.TODO`, если вы не уверены в том, какой Context использовать.
- Используйте контекст `Values` только для данных, скопированных в запрос, которые передаются процессам и API, а не для передачи необязательных параметров функциям.
- Один и тот же Context может быть передан функциям, выполняющимся в разных горутинах; Context'ы безопасны для одновременного использования несколькими горутинами.

** Дополнительное чтение

- [[https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html][Семантика Context пакета в Go]] - Уильям Кеннеди  
- [[https://golang.org/pkg/context][пакет Context]] - Go Team    
- [[https://blog.golang.org/context][Паттерны конкурентности Go: Context]] - Sameer Ajmani    
- [[https://rakyll.org/leakingctx/][Использование Context для предотвращения утечки горутин]] - JBD    

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Приведены возможные решения.

** Упражнение 1

Используйте шаблон и следуйте указаниям. Вам предстоит написать веб-обработчик, который выполняет имитацию вызова базы данных, но если вызов займет слишком много времени, то будет отключен на основе контекста. Вы также будете сохранять состояние в контексте.

.play context/exercise1.go
.play context/answer1.go
