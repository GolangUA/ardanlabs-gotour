Каналы
Каналы позволяют горутинам взаимодействовать друг с другом с помощью сигнальной семантики.

* Каналы

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Смотреть видео]]
Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Важно думать о канале не как о структуре данных, а как о механизме для
передачи сигналов. Это согласуется с идеей, что вы отправляете и получаете из канала,
а не читаете и записываете. Если проблема, стоящая перед вами, не может быть решена с помощью сигнализации,
если слово "сигнализация" не сходит с ваших уст, вам нужно поставить под сомнение использование
каналов.

** Обзор кода

- *Пример* *1:* Дождитесь результата
- *Пример* *2:* Веерный выход
- *Пример* *3:* Ожидание задачи
- *Пример* *4:* Пул
- *Пример* *5:* Веерное удаление семафора
- *Пример* *6:* Ограниченный пул работ
- *Пример* *7:* Drop
- *Пример* *8:* Отмена
- *Пример* *9:* Таймаут повторной попытки
- *Пример* *10:* Отмена канала

.play channels/example1.go
.play channels/example2.go
.play channels/example3.go
.play channels/example4.go
.play channels/example5.go
.play channels/example6.go
.play channels/example7.go
.play channels/example8.go
.play channels/example9.go
.play channels/example10.go

** Механика канала

Ценой гарантии на сигнальном уровне является неизвестная задержка. Отправитель 
не знает, как долго ему придется ждать, пока получатель примет сигнал.
Необходимость ждать получателя создает блокирующую задержку. В этом случае неизвестно
количество блокирующих задержек. Отправителю приходится ждать неизвестно сколько времени,
пока приемник не станет доступен для приема сигнала.

Ожидание получателя означает, что механически операция получения происходит раньше
отправки. В каналах прием происходит на наносекунды раньше, но это раньше.
Это означает, что получатель принимает сигнал и уходит, позволяя отправителю
продолжить работу с гарантией.

А что, если процесс не может ждать неизвестное количество времени? Что, если такая
задержка не сработает? Тогда гарантия не может быть на уровне сигнала, она должна быть
быть вне его. Механика этой работы заключается в том, что отправка теперь происходит
до получения. Отправитель может выполнить сигнал, не нуждаясь в том, чтобы получатель 
был доступен. Таким образом, отправитель может уйти и не ждать. В конце концов, вы надеетесь,
получатель появится и примет сигнал.

Это снижает затраты на задержку при отправке, но создает неопределенность в отношении сигналов
и, следовательно, не известно, есть ли проблемы с получателем.
Это может привести к принятию работы, которая так и не будет начата или закончена. Это
В конечном итоге это может привести к огромному обратному давлению и отказу систем.

Второе, на чем следует сосредоточиться, - нужно ли вам передавать данные вместе с сигналом? Если сигнал
требует передачи данных, то сигнал передается между Goroutine по схеме 1 к 1.
Если новая Goroutine должна получить сигнал, необходимо отправить второй сигнал.

Если при передаче сигнала не требуется передача данных, то сигнал может быть 1 к
1 или 1 ко многим между Go-подпрограммами. Сигнал без данных используется в основном для
отмены или отключения. Это делается путем закрытия канала.

Третье, на чем следует сосредоточиться, - это состояние канала. Канал может находиться в одном из трех состояний.

Канал может находиться в нулевом состоянии, если построить канал в состоянии нулевого значения.
Отправка и получение по каналам в этом состоянии будут блокироваться. Это хорошо подходит для ситуаций.
когда необходимо реализовать кратковременные остановки работы.

Канал можно перевести в открытое состояние с помощью встроенной функции make. Отправка и
приемы по каналам в этом состоянии будут работать при следующих условиях:

*Небуферизованные* *Каналы:*

- Гарантии на уровне сигналов, при этом прием происходит перед отправкой. Отправка
и приемные Goroutines должны сойтись в одном пространстве и времени, чтобы
чтобы сигнал был обработан.

*Буферизованные* *Каналы:*

- Гарантирует вне сигнального уровня, причем отправка происходит раньше, чем
получения. Если буфер не заполнен, отправка может завершиться, иначе она блокируется. Если
буфер не пуст, получатели могут завершить передачу, иначе они блокируются.

Канал может находиться в закрытом состоянии с помощью встроенной функции close. Вам не
закрывать канал для освобождения памяти, это нужно для изменения состояния. Отправка
по закрытому каналу вызовет панику, однако прием по закрытому каналу
вернется немедленно.

Получив всю эту информацию, вы можете сосредоточиться на шаблонах каналов. Фокус на сигнализации
очень важен. Идея заключается в том, нужна ли вам гарантия на уровне сигналов или нет,
исходя из соображений задержки. Нужно ли передавать данные вместе с сигналом или нет, основываясь
обрабатывать отмены или нет. Вы хотите преобразовать синтаксис в эту семантику.

** Руководство по проектированию

- Ознакомьтесь с [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#channel-design]] [рекомендациями по проектированию]] для каналов.

** Диаграммы

*Гарантия* *Доставки*

В основе ``Гарантии доставки`` лежит один вопрос: "Нужна ли мне гарантия того, что
сигнал, посланный конкретной горутиной, был получен?"

.image /tour/eng/static/img/guarantee_of_delivery.png

*Сигнализация* *С* *Или* *Без* *Данных*

Если вы собираетесь подавать сигнал `с данными`, есть три варианта конфигурации канала
в зависимости от типа `гарантии`, которая вам нужна.

.image /tour/eng/static/img/signaling_with_data.png

Сигнализация без данных служит основной цели отмены. Он позволяет одной
горутине сигнализировать другой горутине, чтобы та отменила свои действия и двигалась дальше.
Отмена может быть реализована с использованием как `unbuffered`, так и `buffered` каналов.

.image /tour/eng/static/img/signaling_without_data.png

*Состояние*

Поведение канала напрямую зависит от его текущего `состояния`. На
состояние канала может быть `nil`, `open` или `closed`.

.image /tour/eng/static/img/state.png

** Дополнительное чтение

- [[https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html][The Behavior Of Channels]] - Уильям Кеннеди  
- [[https://golang.org/ref/mem#tmp_7][Коммуникация каналов]]    
- [[http://blog.golang.org/share-memory-by-communicating][Делимся памятью, общаясь]] - Эндрю Джерранд    
- [[https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html][Природа каналов в Go]] - Уильям Кеннеди    
- [[http://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html][Ретроспектива SEDA]] - Мэтт Уэлш    
- [[https://www.youtube.com/watch?v=KBZlN0izeiY][Понимание каналов]] - Kavya Joshi    

** Buffer Bloat - 2011

Будьте осторожны с использованием больших буферов с целью снижения задержки.

- Большие буферы препятствуют своевременному оповещению о противодавлении.
- Они лишают вас возможности своевременно снижать обратное давление.
- Они могут увеличить задержку, а не уменьшить ее.
- Используйте буферизованные каналы для обеспечения непрерывности.
- Не используйте их только для повышения производительности.
- Используйте их для обработки четко определенных всплесков данных.
- Используйте их для решения проблем скорости света между передачами.

*Видео*

- [[https://www.youtube.com/watch?v=qbIozKVz73g][Bufferbloat: темные буферы в Интернете]]  
- [[http://www.bufferbloat.net/projects/cerowrt/wiki/Bloat-videos][Buffer Bloat Videos]]  

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Приведены возможные решения.

** Упражнение 1

Напишите программу, в которой две горутины передают целое число туда и обратно десять раз.
Выведите на экран момент получения целого числа каждой горутиной. Увеличивайте целое число при каждом
передаче. Как только целое число станет равным десяти, завершите программу.

.play channels/exercise1.go 
.play channels/answer1.go

** Упражнение 2

Напишите программу, которая использует шаблон веерной генерации для одновременной генерации 100 случайных чисел.
Пусть каждая горутина генерирует одно случайное число и возвращает его главному,
буферизованному каналу. Установите размер буферного канала так, чтобы ни одна отправка никогда не
блокируется. Не выделяйте буфер больше, чем вам нужно. Пусть главная горутина отображает каждое
случайное число, которое она получает, а затем завершает программу.

.play channels/exercise2.go 
.play channels/answer2.go

** Упражнение 3

Напишите программу, которая одновременно генерирует до 100 случайных чисел. Не отправляйте
все 100 значений, поэтому количество отправленных/полученных чисел неизвестно.

.play channels/exercise3.go 
.play channels/answer3.go
 
** Упражнение 4

Напишите программу, которая одновременно генерирует до 100 случайных чисел, используя рабочий
пул. Отклоняйте четные значения. Прикажите рабочим прекратить работу, когда 100 нечетных чисел 
собраны.

.play channels/exercise4.go 
.play channels/answer4.go
